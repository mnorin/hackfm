# fs.class - File system operations for HackFM
# Handles: mkdir, delete, copy, move, extract

make_directory() {
    # Get current path from active panel
    local list=$(get_active_panel).list
    local path=$($list.path)
    
    # Show input dialog (capture result without triggering error trap)
    local dialog_result=0
    file_dialog.show_input "Make Directory" "Enter directory name:" "" || dialog_result=$?
    
    # Cleanup after dialog
    dialog_cleanup
    
    if [ $dialog_result -eq 0 ]; then
        local dirname="$(file_dialog.input_value)"
        
        # Validate input
        if [ -z "$dirname" ]; then
            show_error "Directory name cannot be empty"
            return
        fi
        
        # Create directory
        local fullpath="$path/$dirname"
        
        if mkdir "$fullpath" 2>/dev/null; then
            # Success - reload directory and select newly created
            reload_active_panel

            # Find and select the new directory
            local panel=$(get_active_panel)
            local panel_height=$($panel.height)
            $list.find_and_select "$dirname" $((panel_height - 3))

            # Re-render row cache so highlight matches new cursor position
            $panel.prerender_all_rows

            broker.publish "dialog_closed" ""
        else
            # Error
            show_error "Failed to create directory: $dirname"
        fi
    else
        # Cancelled
        broker.publish "dialog_closed" ""
    fi
}

# Delete file/directory (F8)
delete_item() {
    local active_list=$(get_active_panel).list
    local path=$($active_list.path)
    
    # Remember cursor position before operation
    local saved_index=$($active_list.selected)
    
    # Check if there are selected files
    local selected_count=$($active_list.count_selected)
    
    if [ $selected_count -gt 0 ]; then
        # Get selection info from filelist
        local sel_info=$($active_list.selection_info)
        local total_bytes="${sel_info#*|}"
        
        # Format total size
        local size_str
        if [ $total_bytes -lt 1024 ]; then
            size_str="${total_bytes}B"
        elif [ $total_bytes -lt 1048576 ]; then
            size_str="$((total_bytes / 1024))KB"
        else
            size_str="$((total_bytes / 1048576))MB"
        fi
        
        # Delete selected files
        local confirm_result=0
        file_dialog.show_confirm "Delete" "Delete $selected_count files ($size_str)?" || confirm_result=$?
        
        dialog_cleanup
        
        if [ $confirm_result -ne 0 ]; then
            broker.publish "dialog_closed" ""
            return
        fi
        
        # Delete each selected file
        local failed=0
        while IFS='|' read -r filename filetype; do
            local fullpath="$path/$filename"
            
            if [ "$filetype" = "d" ]; then
                rm -rf "$fullpath" 2>/dev/null || failed=1
            else
                rm "$fullpath" 2>/dev/null || failed=1
            fi
        done < <($active_list.get_selected)
        
        if [ $failed -eq 1 ]; then
            show_error "Some files failed to delete"
        fi
        
        reload_active_panel
        
        # Position cursor intelligently after delete (files are gone)
        local file_count=$($active_list.count)
        
        local new_index=$saved_index
        if [ $new_index -ge $file_count ] && [ $file_count -gt 0 ]; then
            new_index=$((file_count - 1))
        fi
        
        $active_list.selected = $new_index
        
        # Adjust scroll if needed
        local active_panel=$(get_active_panel)
        local panel_height=$($active_panel.height)
        local max_visible=$((panel_height - 3))
        local scroll=$($active_list.scroll)
        
        if [ $new_index -lt $scroll ]; then
            $active_list.scroll = $new_index
        elif [ $new_index -ge $((scroll + max_visible)) ]; then
            $active_list.scroll = $((new_index - max_visible + 1))
        fi
        
        broker.publish "dialog_closed" ""
    else
        # No selection - delete cursor item (original behavior)
        local filename filetype
        IFS='|' read -r filename filetype path <<< "$(get_selected_item)"
        
        if $active_list.is_special "$filename"; then
            return
        fi
        
        local current_index=$($active_list.selected)
        local fullpath="$path/$filename"
        
        local confirm_result=0
        if [ "$filetype" = "d" ]; then
            file_dialog.show_confirm "Delete Directory" "Delete directory '$filename'?" || confirm_result=$?
        else
            file_dialog.show_confirm "Delete File" "Delete file '$filename'?" || confirm_result=$?
        fi
        
        dialog_cleanup
        
        if [ $confirm_result -ne 0 ]; then
            broker.publish "dialog_closed" ""
            return
        fi
        
        local delete_success=0
        
        if [ "$filetype" = "d" ]; then
            if rmdir "$fullpath" 2>/dev/null; then
                delete_success=1
            else
                local recursive_result=0
                file_dialog.show_confirm "Directory Not Empty" "Directory is not empty. Delete recursively?" || recursive_result=$?
                dialog_cleanup
                
                if [ $recursive_result -eq 0 ]; then
                    if rm -rf "$fullpath" 2>/dev/null; then
                        delete_success=1
                    else
                        show_error "Failed to delete directory"
                        return
                    fi
                else
                    broker.publish "dialog_closed" ""
                    return
                fi
            fi
        else
            if rm "$fullpath" 2>/dev/null; then
                delete_success=1
            else
                show_error "Failed to delete file"
                return
            fi
        fi
        
        if [ $delete_success -eq 1 ]; then
            # Reload panel - it will preserve cursor position
            local active_panel=$(get_active_panel)
            $active_panel.reload
            
            broker.publish "dialog_closed" ""
        fi
    fi
}

# Extract files from archive (F5 when active panel is in an archive)
extract_item() {
    local active_panel=$(get_active_panel)
    local active_list=$($active_panel.list_source)
    local other_list=$($(get_other_panel).list_source)
    local dest_path=$($other_list.path)

    local archive_path=$($active_panel.archive_path)
    local archive_name=$(basename "$archive_path")

    # Get cursor item
    local filename filetype fpath
    IFS='|' read -r filename filetype fpath <<< "$($active_list.get_selected_item)"

    # Skip special entries
    if [ "$filename" = ".." ] || [ "$filename" = "<empty>" ]; then
        return
    fi

    # Use marked files if any, otherwise cursor item
    local files_to_extract=()
    local extract_label=""
    local marked_count=$($active_list.count_selected)
    if [ "$marked_count" -gt 0 ]; then
        while IFS= read -r p; do
            files_to_extract+=("$p")
        done < <($active_list.get_marked_paths)
        extract_label="$marked_count file(s)"
    else
        files_to_extract=("$fpath")
        extract_label="\"$filename\""
    fi

    # Calculate dialog dimensions
    local size=$(tui.screen.size)
    local rows=${size% *}
    local cols=${size#* }
    local dialog_width=60
    [ $dialog_width -gt $((cols - 4)) ] && dialog_width=$((cols - 4))
    local dialog_height=9
    local dialog_row=$(( (rows - dialog_height) / 2 ))
    local dialog_col=$(( (cols - dialog_width) / 2 ))

    # Draw dialog shadow
    tui.color.bg_black
    for ((r=dialog_row+1; r<dialog_row+dialog_height+1; r++)); do
        tui.cursor.move $r $((dialog_col + 2))
        printf "%$((dialog_width))s" ""
    done
    tui.color.reset

    # Draw dialog box
    tui.color.bg_white
    tui.color.black
    for ((r=dialog_row; r<dialog_row+dialog_height; r++)); do
        tui.cursor.move $r $dialog_col
        printf "%${dialog_width}s" ""
    done

    tui.cursor.move $dialog_row $dialog_col
    tui.box.draw $dialog_row $dialog_col $dialog_width $dialog_height

    # Title
    tui.cursor.move $dialog_row $((dialog_col + 2))
    tui.color.bg_white
    tui.color.black
    tui.color.bold
    printf " Extract "
    tui.color.reset

    # Source label
    tui.cursor.move $((dialog_row + 2)) $((dialog_col + 2))
    tui.color.bg_white
    tui.color.black
    printf "%-$((dialog_width - 4))s" "From: $archive_name  $extract_label"

    # Destination label
    tui.cursor.move $((dialog_row + 3)) $((dialog_col + 2))
    printf "%-$((dialog_width - 4))s" "To:"

    # Destination input field (editable)
    local input="$dest_path"
    local cursor_pos=${#input}
    local field_width=$((dialog_width - 4))

    tui.cursor.show
    while true; do
        # Redraw input field
        tui.cursor.move $((dialog_row + 4)) $((dialog_col + 2))
        tui.color.bg_cyan
        tui.color.black
        # Show end of path if longer than field
        local display_input="$input"
        if [ ${#display_input} -gt $field_width ]; then
            display_input="${display_input:$((${#display_input} - field_width))}"
        fi
        printf "%-${field_width}s" "$display_input"
        tui.color.reset

        # Draw buttons
        tui.cursor.move $((dialog_row + 6)) $((dialog_col + dialog_width/2 - 9))
        tui.color.bg_cyan
        tui.color.black
        tui.color.bold
        printf "[ Extract ]"
        tui.color.reset
        tui.color.bg_white
        tui.color.black
        printf "   "
        tui.color.bold
        printf "[Cancel]"
        tui.color.reset

        # Position cursor in input field
        local visible_cursor=$cursor_pos
        if [ ${#input} -gt $field_width ]; then
            visible_cursor=$((field_width))
        fi
        tui.cursor.move $((dialog_row + 4)) $((dialog_col + 2 + visible_cursor))

        local key=$(tui.input.key)
        case "$key" in
            ENTER)
                tui.cursor.hide
                break
                ;;
            ESC)
                tui.cursor.hide
                dialog_cleanup
                broker.publish "dialog_closed" ""
                return
                ;;
            BACKSPACE)
                if [ $cursor_pos -gt 0 ]; then
                    input="${input:0:$((cursor_pos-1))}${input:$cursor_pos}"
                    cursor_pos=$((cursor_pos - 1))
                fi
                ;;
            DELETE)
                if [ $cursor_pos -lt ${#input} ]; then
                    input="${input:0:$cursor_pos}${input:$((cursor_pos+1))}"
                fi
                ;;
            LEFT)
                [ $cursor_pos -gt 0 ] && cursor_pos=$((cursor_pos - 1)) ;;
            RIGHT)
                [ $cursor_pos -lt ${#input} ] && cursor_pos=$((cursor_pos + 1)) ;;
            HOME) cursor_pos=0 ;;
            END)  cursor_pos=${#input} ;;
            *)
                if [ ${#key} -eq 1 ]; then
                    input="${input:0:$cursor_pos}${key}${input:$cursor_pos}"
                    cursor_pos=$((cursor_pos + 1))
                fi
                ;;
        esac
    done

    dialog_cleanup

    # Do the extraction
    local dest="$input"
    if [ -z "$dest" ]; then
        broker.publish "dialog_closed" ""
        return
    fi

    # Get the archivelist object from the active panel
    local arch_list=$($active_panel.list_source)
    local result
    _extract_with_progress "$arch_list" "$dest" "${files_to_extract[@]}"
    result=$?

    reload_other_panel
    broker.publish "dialog_closed" ""

    if [ $result -ne 0 ]; then
        show_error "Extraction failed"
    fi
}

# Extract files with progress dialog shown per file.
# Args: arch_list dest files_to_extract...
_extract_with_progress() {
    local arch_list="$1"
    local dest="$2"
    shift 2
    local files=("$@")
    local total=${#files[@]}

    tui.cursor.hide

    if [ $total -eq 0 ]; then
        # Extract all - no per-file progress, just status
        _draw_status_dialog "Extract" "Extracting archive..."
        $arch_list.extract_files "$dest"
        tui.cursor.show
        return $?
    fi

    local failed=0
    local i
    for ((i=0; i<total; i++)); do
        local f="${files[$i]}"
        local label="${f##*/}"
        _draw_progress_dialog "Extract" "$label" \
            "$i" "$total" \
            "$i" "$total"
        $arch_list.extract_files "$dest" "$f" || failed=1
    done

    # Draw 100%
    _draw_progress_dialog "Extract" "Done" "$total" "$total" "$total" "$total"
    tui.cursor.show
    return $failed
}



# Draw a progress dialog.
# Args: title file_label bytes_done bytes_total files_done files_total
# Show a simple status message dialog (no buttons).
# Args: title message
# Draw a red error dialog with support for two lines of message
# Recursively collect all regular files under a path into __FILE_LIST array.
# Also accumulates total size in __FILE_LIST_TOTAL_BYTES.
# Args: base_source_path base_dest_path
declare -ag __FILE_LIST_SRC=()
declare -ag __FILE_LIST_DST=()
declare -ag __FILE_LIST_SIZES=()
__FILE_LIST_TOTAL_BYTES=0

_build_file_list() {
    local src="$1"
    local dst="$2"

    __FILE_LIST_SRC=()
    __FILE_LIST_DST=()
    __FILE_LIST_SIZES=()
    __FILE_LIST_TOTAL_BYTES=0

    _build_file_list_recurse "$src" "$dst"
}

_build_file_list_recurse() {
    local src="$1"
    local dst="$2"

    if [ -d "$src" ]; then
        # Recurse into directory
        local entry
        while IFS= read -r -d '' entry; do
            local name="${entry##*/}"
            _build_file_list_recurse "$entry" "$dst/$name"
        done < <(find "$src" -maxdepth 1 -mindepth 1 -print0 2>/dev/null)
    elif [ -f "$src" ]; then
        local size
        size=$(stat -c '%s' "$src" 2>/dev/null || echo 0)
        __FILE_LIST_SRC+=("$src")
        __FILE_LIST_DST+=("$dst")
        __FILE_LIST_SIZES+=("$size")
        __FILE_LIST_TOTAL_BYTES=$(( __FILE_LIST_TOTAL_BYTES + size ))
    fi
}

# Copy a single file using dd, updating the progress dialog via stat polling.
# Args: src dst file_size files_done files_total bytes_done_before title
_copy_file_with_progress() {
    local src="$1"
    local dst="$2"
    local file_size="$3"
    local files_done="$4"
    local files_total="$5"
    local bytes_before="$6"
    local title="$7"

    # Ensure destination directory exists
    local dst_dir="${dst%/*}"
    mkdir -p "$dst_dir" 2>/dev/null

    local file_label="${src##*/}"

    # Run dd in background
    dd if="$src" of="$dst" bs=65536 status=none 2>/dev/null &
    local dd_pid=$!

    # Poll destination file size until dd finishes
    while kill -0 $dd_pid 2>/dev/null; do
        local bytes_copied
        bytes_copied=$(stat -c '%s' "$dst" 2>/dev/null || echo 0)
        _draw_progress_dialog "$title" "$file_label" \
            "$bytes_copied" "$file_size" \
            "$files_done" "$files_total"
        sleep 0.1
    done

    wait $dd_pid
    local rc=$?

    # Draw 100% for this file before moving on
    _draw_progress_dialog "$title" "$file_label" \
        "$file_size" "$file_size" \
        "$((files_done + 1))" "$files_total"

    return $rc
}

# Copy file/directory (F5)
copy_item() {
    local active_list=$(get_active_panel).list
    local source_path=$($active_list.path)
    local other_list=$(get_other_panel).list
    local dest_path=$($other_list.path)
    
    # Remember cursor position before operation
    local saved_index=$($active_list.selected)
    local filename_for_restore filetype_tmp path_tmp
    IFS='|' read -r filename_for_restore filetype_tmp path_tmp <<< "$(get_selected_item)"
    
    # Check if there are selected files
    local selected_count=$($active_list.count_selected)
    
    if [ $selected_count -gt 0 ]; then
        # Get selection info from filelist
        local sel_info=$($active_list.selection_info)
        local total_bytes="${sel_info#*|}"
        
        # Format total size
        local size_str
        if [ $total_bytes -lt 1024 ]; then
            size_str="${total_bytes}B"
        elif [ $total_bytes -lt 1048576 ]; then
            size_str="$((total_bytes / 1024))KB"
        else
            size_str="$((total_bytes / 1048576))MB"
        fi
        
        # Show confirmation with From/To in a custom dialog
        local confirm_result=0
        
        # Calculate dialog size based on path lengths
        local max_path_len=${#source_path}
        [ ${#dest_path} -gt $max_path_len ] && max_path_len=${#dest_path}
        
        local dialog_width=$((max_path_len + 10))  # Add padding
        [ $dialog_width -lt 50 ] && dialog_width=50  # Minimum width
        [ $dialog_width -gt 70 ] && dialog_width=70  # Maximum width
        
        local dialog_height=9
        
        # Get terminal size
        local size=$(tui.screen.size)
        local rows=${size% *}
        local cols=${size#* }
        local dialog_row=$(( (rows - dialog_height) / 2 ))
        local dialog_col=$(( (cols - dialog_width) / 2 ))
        
        # Draw dialog background (shadow)
        tui.color.bg_black
        for ((r=dialog_row+1; r<dialog_row+dialog_height+1; r++)); do
            tui.cursor.move $r $((dialog_col + 2))
            printf "%$((dialog_width))s" ""
        done
        tui.color.reset
        
        # Draw dialog box
        tui.color.bg_white
        tui.color.black
        for ((r=dialog_row; r<dialog_row+dialog_height; r++)); do
            tui.cursor.move $r $dialog_col
            printf "%${dialog_width}s" ""
        done
        
        # Draw border
        tui.cursor.move $dialog_row $dialog_col
        tui.box.draw $dialog_row $dialog_col $dialog_width $dialog_height
        
        # Draw title
        tui.cursor.move $dialog_row $((dialog_col + 2))
        tui.color.bg_white
        tui.color.black
        tui.color.bold
        printf " Copy "
        tui.color.reset
        
        # Draw message
        tui.cursor.move $((dialog_row + 2)) $((dialog_col + 2))
        tui.color.bg_white
        tui.color.black
        printf "Copy %d files (%s)" "$selected_count" "$size_str"
        
        # Draw From:
        tui.cursor.move $((dialog_row + 4)) $((dialog_col + 2))
        tui.color.bold
        printf "From: "
        tui.color.reset
        tui.color.bg_white
        tui.color.black
        # Truncate path if too long
        local from_max=$((dialog_width - 10))
        local from_display="$source_path"
        if [ ${#from_display} -gt $from_max ]; then
            from_display="...${source_path: -$((from_max - 3))}"
        fi
        printf "%s" "$from_display"
        
        # Draw To:
        tui.cursor.move $((dialog_row + 5)) $((dialog_col + 2))
        tui.color.bold
        printf "To:   "
        tui.color.reset
        tui.color.bg_white
        tui.color.black
        local to_display="$dest_path"
        if [ ${#to_display} -gt $from_max ]; then
            to_display="...${dest_path: -$((from_max - 3))}"
        fi
        printf "%s" "$to_display"
        
        # Draw buttons
        local selected_btn=0  # 0=Yes, 1=No
        
        while true; do
            tui.cursor.move $((dialog_row + 7)) $((dialog_col + dialog_width/2 - 8))
            
            if [ $selected_btn -eq 0 ]; then
                tui.color.bg_cyan
                tui.color.black
                tui.color.bold
            else
                tui.color.bg_white
                tui.color.black
            fi
            printf "[ Yes ]"
            tui.color.reset
            
            tui.color.bg_white
            tui.color.black
            printf "   "
            
            if [ $selected_btn -eq 1 ]; then
                tui.color.bg_cyan
                tui.color.black
                tui.color.bold
            else
                tui.color.bg_white
                tui.color.black
            fi
            printf "[ No ]"
            tui.color.reset
            
            # Read key
            local key=$(tui.input.key)
            
            case "$key" in
                LEFT|RIGHT|TAB)
                    selected_btn=$((1 - selected_btn))
                    ;;
                ENTER)
                    if [ $selected_btn -eq 0 ]; then
                        confirm_result=0
                    else
                        confirm_result=1
                    fi
                    break
                    ;;
                ESC)
                    confirm_result=1
                    break
                    ;;
            esac
        done
        
        broker.publish "dialog_closed" ""
        
        if [ $confirm_result -ne 0 ]; then
            return
        fi
        
        # Show "Preparing..." while building complete file list across all selected items
        _draw_status_dialog "Copy" "Preparing..."
        __FILE_LIST_SRC=()
        __FILE_LIST_DST=()
        __FILE_LIST_SIZES=()
        __FILE_LIST_TOTAL_BYTES=0
        while IFS='|' read -r filename filetype; do
            local source="$source_path/$filename"
            local destination="$dest_path/$filename"
            _build_file_list_recurse "$source" "$destination"
        done < <($active_list.get_selected)

        # Copy all files with unified progress counters
        local failed=0 i
        for ((i=0; i<${#__FILE_LIST_SRC[@]}; i++)); do
            _copy_file_with_progress \
                "${__FILE_LIST_SRC[$i]}" \
                "${__FILE_LIST_DST[$i]}" \
                "${__FILE_LIST_SIZES[$i]}" \
                "$i" "${#__FILE_LIST_SRC[@]}" \
                "0" "Copy" || failed=1
        done
        
        tui.cursor.show
        if [ $failed -eq 1 ]; then
            show_error "Some files failed to copy"
        fi
        
        reload_both_panels
        
        # Restore cursor position
        local active_panel=$(get_active_panel)
        local panel_height=$($active_panel.height)
        $active_list.find_and_select "$filename_for_restore" $((panel_height - 3))
        
        broker.publish "dialog_closed" ""
    else
        # No selection - copy cursor item (original behavior)
        local filename filetype
        IFS='|' read -r filename filetype source_path <<< "$(get_selected_item)"
        
        # Don't copy special items
        if $active_list.is_special "$filename"; then
            return
        fi
        
        # Remember current selection to restore later
        local current_selection="$filename"
        
        # Show input dialog with default destination (other panel's path)
        local default_dest="$dest_path/$filename"
        
        if ! show_path_input "Copy" "Copy to:" "$default_dest"; then
            # Cancelled
            broker.publish "dialog_closed" ""
            return
        fi
        
        local destination="$CUSTOM_INPUT_RESULT"
        
        # Validate input
        if [ -z "$destination" ]; then
            show_error "Destination cannot be empty"
            return
        fi
        
        # If destination is relative (no leading /), make it relative to source directory
        if [[ "$destination" != /* ]]; then
            destination="$source_path/$destination"
        fi
        
        local source="$source_path/$filename"
        
        # Check if destination exists
        if [ -e "$destination" ]; then
            local confirm_result=0
            file_dialog.show_confirm "Overwrite?" "Destination exists. Overwrite?" || confirm_result=$?
            dialog_cleanup
            
            if [ $confirm_result -ne 0 ]; then
                broker.publish "dialog_closed" ""
                return
            fi
        fi
        
        # Copy with progress
        _draw_status_dialog "Copy" "Preparing..."
        _build_file_list "$source" "$destination"

        local i bytes_done=0 failed=0
        for ((i=0; i<${#__FILE_LIST_SRC[@]}; i++)); do
            _copy_file_with_progress \
                "${__FILE_LIST_SRC[$i]}" \
                "${__FILE_LIST_DST[$i]}" \
                "${__FILE_LIST_SIZES[$i]}" \
                "$i" "${#__FILE_LIST_SRC[@]}" \
                "$bytes_done" "Copy" || failed=1
            bytes_done=$(( bytes_done + __FILE_LIST_SIZES[$i] ))
        done

        tui.cursor.show
        if [ $failed -eq 0 ]; then
            # Success - reload both panels
            reload_both_panels
            
            # Restore cursor position to the same file in source panel
            local active_panel=$(get_active_panel)
            local panel_height=$($active_panel.height)
            $active_list.find_and_select "$current_selection" $((panel_height - 3))
            $active_panel.prerender_all_rows
            
            broker.publish "dialog_closed" ""
        else
            show_error "Failed to copy"
        fi
    fi
}

# Move/rename file/directory (F6)
move_item() {
    local active_list=$(get_active_panel).list
    local source_path=$($active_list.path)
    local other_list=$(get_other_panel).list
    local dest_path=$($other_list.path)
    
    # Remember cursor position before operation
    local saved_index=$($active_list.selected)
    local filename_for_restore filetype_tmp path_tmp
    IFS='|' read -r filename_for_restore filetype_tmp path_tmp <<< "$(get_selected_item)"
    
    # Check if there are selected files
    local selected_count=$($active_list.count_selected)
    
    if [ $selected_count -gt 0 ]; then
        # Get selection info from filelist
        local sel_info=$($active_list.selection_info)
        local total_bytes="${sel_info#*|}"
        
        # Format total size
        local size_str
        if [ $total_bytes -lt 1024 ]; then
            size_str="${total_bytes}B"
        elif [ $total_bytes -lt 1048576 ]; then
            size_str="$((total_bytes / 1024))KB"
        else
            size_str="$((total_bytes / 1048576))MB"
        fi
        
        # Show confirmation with From/To in a custom dialog
        local confirm_result=0
        
        # Calculate dialog size based on path lengths
        local max_path_len=${#source_path}
        [ ${#dest_path} -gt $max_path_len ] && max_path_len=${#dest_path}
        
        local dialog_width=$((max_path_len + 10))
        [ $dialog_width -lt 50 ] && dialog_width=50
        [ $dialog_width -gt 70 ] && dialog_width=70
        
        local dialog_height=9
        
        # Get terminal size
        local size=$(tui.screen.size)
        local rows=${size% *}
        local cols=${size#* }
        local dialog_row=$(( (rows - dialog_height) / 2 ))
        local dialog_col=$(( (cols - dialog_width) / 2 ))
        
        # Draw dialog background (shadow)
        tui.color.bg_black
        for ((r=dialog_row+1; r<dialog_row+dialog_height+1; r++)); do
            tui.cursor.move $r $((dialog_col + 2))
            printf "%$((dialog_width))s" ""
        done
        tui.color.reset
        
        # Draw dialog box
        tui.color.bg_white
        tui.color.black
        for ((r=dialog_row; r<dialog_row+dialog_height; r++)); do
            tui.cursor.move $r $dialog_col
            printf "%${dialog_width}s" ""
        done
        
        # Draw border
        tui.cursor.move $dialog_row $dialog_col
        tui.box.draw $dialog_row $dialog_col $dialog_width $dialog_height
        
        # Draw title
        tui.cursor.move $dialog_row $((dialog_col + 2))
        tui.color.bg_white
        tui.color.black
        tui.color.bold
        printf " Move "
        tui.color.reset
        
        # Draw message
        tui.cursor.move $((dialog_row + 2)) $((dialog_col + 2))
        tui.color.bg_white
        tui.color.black
        printf "Move %d files (%s)" "$selected_count" "$size_str"
        
        # Draw From:
        tui.cursor.move $((dialog_row + 4)) $((dialog_col + 2))
        tui.color.bold
        printf "From: "
        tui.color.reset
        tui.color.bg_white
        tui.color.black
        local from_max=$((dialog_width - 10))
        local from_display="$source_path"
        if [ ${#from_display} -gt $from_max ]; then
            from_display="...${source_path: -$((from_max - 3))}"
        fi
        printf "%s" "$from_display"
        
        # Draw To:
        tui.cursor.move $((dialog_row + 5)) $((dialog_col + 2))
        tui.color.bold
        printf "To:   "
        tui.color.reset
        tui.color.bg_white
        tui.color.black
        local to_display="$dest_path"
        if [ ${#to_display} -gt $from_max ]; then
            to_display="...${dest_path: -$((from_max - 3))}"
        fi
        printf "%s" "$to_display"
        
        # Draw buttons
        local selected_btn=0
        
        while true; do
            tui.cursor.move $((dialog_row + 7)) $((dialog_col + dialog_width/2 - 8))
            
            if [ $selected_btn -eq 0 ]; then
                tui.color.bg_cyan
                tui.color.black
                tui.color.bold
            else
                tui.color.bg_white
                tui.color.black
            fi
            printf "[ Yes ]"
            tui.color.reset
            
            tui.color.bg_white
            tui.color.black
            printf "   "
            
            if [ $selected_btn -eq 1 ]; then
                tui.color.bg_cyan
                tui.color.black
                tui.color.bold
            else
                tui.color.bg_white
                tui.color.black
            fi
            printf "[ No ]"
            tui.color.reset
            
            local key=$(tui.input.key)
            
            case "$key" in
                LEFT|RIGHT|TAB)
                    selected_btn=$((1 - selected_btn))
                    ;;
                ENTER)
                    if [ $selected_btn -eq 0 ]; then
                        confirm_result=0
                    else
                        confirm_result=1
                    fi
                    break
                    ;;
                ESC)
                    confirm_result=1
                    break
                    ;;
            esac
        done
        
        broker.publish "dialog_closed" ""
        
        if [ $confirm_result -ne 0 ]; then
            return
        fi
        
        # Try mv for all selected items first (instant on same filesystem).
        # Collect any that fail (cross-filesystem) for dd+progress treatment.
        local failed=0
        local -a _mv_src=() _mv_dst=()
        while IFS='|' read -r filename filetype; do
            local source="$source_path/$filename"
            local destination="$dest_path/$filename"
            if ! mv "$source" "$destination" 2>/dev/null; then
                _mv_src+=("$source")
                _mv_dst+=("$destination")
            fi
        done < <($active_list.get_selected)

        # Any cross-filesystem items: build full file list then copy+delete
        if [ ${#_mv_src[@]} -gt 0 ]; then
            _draw_status_dialog "Move" "Preparing..."
            __FILE_LIST_SRC=()
            __FILE_LIST_DST=()
            __FILE_LIST_SIZES=()
            __FILE_LIST_TOTAL_BYTES=0
            local j
            for ((j=0; j<${#_mv_src[@]}; j++)); do
                _build_file_list_recurse "${_mv_src[$j]}" "${_mv_dst[$j]}"
            done
            local i
            for ((i=0; i<${#__FILE_LIST_SRC[@]}; i++)); do
                _copy_file_with_progress \
                    "${__FILE_LIST_SRC[$i]}" \
                    "${__FILE_LIST_DST[$i]}" \
                    "${__FILE_LIST_SIZES[$i]}" \
                    "$i" "${#__FILE_LIST_SRC[@]}" \
                    "0" "Move" || { failed=1; break; }
            done
            if [ $failed -eq 0 ]; then
                for ((j=0; j<${#_mv_src[@]}; j++)); do
                    rm -rf "${_mv_src[$j]}" 2>/dev/null || failed=1
                done
            fi
        fi
        
        tui.cursor.show
        if [ $failed -eq 1 ]; then
            show_error "Some files failed to move"
        fi
        
        reload_both_panels
        
        # After move, files are gone, so position cursor intelligently
        local file_count=$($active_list.count)
        
        local new_index=$saved_index
        if [ $new_index -ge $file_count ] && [ $file_count -gt 0 ]; then
            new_index=$((file_count - 1))
        fi
        
        $active_list.selected = $new_index
        
        # Adjust scroll if needed
        local active_panel=$(get_active_panel)
        local panel_height=$($active_panel.height)
        local max_visible=$((panel_height - 3))
        local scroll=$($active_list.scroll)
        
        if [ $new_index -lt $scroll ]; then
            $active_list.scroll = $new_index
        elif [ $new_index -ge $((scroll + max_visible)) ]; then
            $active_list.scroll = $((new_index - max_visible + 1))
        fi
        
        broker.publish "dialog_closed" ""
    else
        # No selection - move cursor item (original behavior)
        local filename filetype
        IFS='|' read -r filename filetype source_path <<< "$(get_selected_item)"
        
        if $active_list.is_special "$filename"; then
            return
        fi
        
        local current_index=$($active_list.selected)
        local default_dest="$dest_path/$filename"
        
        if ! show_path_input "Move/Rename" "Move to:" "$default_dest"; then
            broker.publish "dialog_closed" ""
            return
        fi
        
        local destination="$CUSTOM_INPUT_RESULT"
        
        if [ -z "$destination" ]; then
            show_error "Destination cannot be empty"
            return
        fi
        
        if [[ "$destination" != /* ]]; then
            destination="$source_path/$destination"
        fi
        
        local source="$source_path/$filename"
        
        if [ -e "$destination" ]; then
            local confirm_result=0
            file_dialog.show_confirm "Overwrite?" "Destination exists. Overwrite?" || confirm_result=$?
            dialog_cleanup
            
            if [ $confirm_result -ne 0 ]; then
                broker.publish "dialog_closed" ""
                return
            fi
        fi

        # Try mv first (instant on same filesystem)
        local move_ok=0
        if mv "$source" "$destination" 2>/dev/null; then
            move_ok=1
        else
            # Cross-filesystem: copy with progress then delete source
            _draw_status_dialog "Move" "Preparing..."
            _build_file_list "$source" "$destination"
            local i bytes_done=0 failed=0
            for ((i=0; i<${#__FILE_LIST_SRC[@]}; i++)); do
                _copy_file_with_progress \
                    "${__FILE_LIST_SRC[$i]}" \
                    "${__FILE_LIST_DST[$i]}" \
                    "${__FILE_LIST_SIZES[$i]}" \
                    "$i" "${#__FILE_LIST_SRC[@]}" \
                    "$bytes_done" "Move" || { failed=1; break; }
                bytes_done=$(( bytes_done + __FILE_LIST_SIZES[$i] ))
            done
            [ $failed -eq 0 ] && rm -rf "$source" 2>/dev/null && move_ok=1
        fi

        tui.cursor.show
        if [ $move_ok -eq 1 ]; then
            reload_both_panels
            
            local file_count=$($active_list.count)
            
            local new_index=$current_index
            if [ $current_index -ge $((file_count - 1)) ] && [ $current_index -gt 0 ]; then
                new_index=$((current_index - 1))
            fi
            
            $active_list.selected = $new_index
            
            local active_panel=$(get_active_panel)
            local panel_height=$($active_panel.height)
            local max_visible=$((panel_height - 3))
            local scroll=$($active_list.scroll)
            
            if [ $new_index -lt $scroll ]; then
                $active_list.scroll = $new_index
            elif [ $new_index -ge $((scroll + max_visible)) ]; then
                $active_list.scroll = $((new_index - max_visible + 1))
            fi
            
            $active_panel.prerender_all_rows
            
            broker.publish "dialog_closed" ""
        else
            show_error "Failed to move"
        fi
    fi
}

# ============================================================================
