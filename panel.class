#!/bin/bash
# panel.class - File panel using ba.sh

# Color/style constants - captured once to avoid subshell overhead in render_row_string.
# Each $(tui.color.*) call forks a subshell; using variables eliminates that cost
# across the inner loop of prerender_all_rows.
_PC_BG_BLUE=$(tui.color.bg_blue)
_PC_BG_CYAN=$(tui.color.bg_cyan)
_PC_BLACK=$(tui.color.black)
_PC_WHITE=$(tui.color.white)
_PC_CYAN=$(tui.color.cyan)
_PC_YELLOW=$(tui.color.yellow)
_PC_BRIGHT_GREEN=$(tui.color.bright_green)
_PC_BRIGHT_YELLOW=$(tui.color.bright_yellow)
_PC_BOLD=$(tui.style.bold)
_PC_REGULAR=$(tui.style.regular)
_PC_RESET=$(tui.style.reset)

declare -Ag __PANEL___properties=()

__PANEL__.property(){
    if [ "$2" = "=" ]; then
        __PANEL___properties[$1]="$3"
    else
        echo "${__PANEL___properties[$1]}"
    fi
}


__PANEL__.x(){      __PANEL__.property x      "$@"; }
__PANEL__.y(){      __PANEL__.property y      "$@"; }
__PANEL__.width(){  __PANEL__.property width  "$@"; }
__PANEL__.height(){ __PANEL__.property height "$@"; }

__PANEL__.active(){
    if [ "$1" = "=" ]; then
        local old_value=$(__PANEL__.property active)
        __PANEL__.property active = "$2"
        # Update only what changes when active status changes
        if [ "$old_value" != "$2" ]; then
            # If this is the initial activation (old_value is empty), do full render
            if [ -z "$old_value" ]; then
                __PANEL__.prerender_all_rows
                __PANEL__.render
            else
                # Subsequent activations: just update header and cursor row
                # Update header color
                __PANEL__.draw_header
                
                # Update cursor row (changes color based on active status)
                local list=$(__PANEL__.list_source)
                local selected=$($list.selected)
                __PANEL__.update_rendered_row $selected
                
                # Draw the updated cursor row
                local y=$(__PANEL__.y)
                local x=$(__PANEL__.x)
                local scroll=$($list.scroll)
                local height=$(__PANEL__.height)
                local max_visible=$((height - 3))
                local visible_row=$((selected - scroll))
                
                if [ $visible_row -ge 0 ] && [ $visible_row -lt $max_visible ]; then
                    tui.cursor.move $((y + 1 + visible_row)) $((x + 1))
                    printf '%b' "${__PANEL___rendered_rows[$selected]}"
                fi
            fi
            
            # Also cd to this panel's directory when becoming active
            if [ "$2" = "1" ]; then
                local list=$(__PANEL__.list_source)
                local path=$($list.path)
                cd "$path" 2>/dev/null || true
                __PANEL__._publish_dir
            fi
        fi
    else
        __PANEL__.property active
    fi
}

__PANEL__.search_text(){    __PANEL__.property search_text    "$@"; }
__PANEL__.enter_result(){   __PANEL__.property enter_result   "$@"; }
__PANEL__.archive_path(){   __PANEL__.property archive_path   "$@"; }
__PANEL__.message_broker(){ __PANEL__.property message_broker "$@"; }
__PANEL__.dialog(){         __PANEL__.property dialog         "$@"; }

__PANEL__.mode(){
    if [ "$1" = "=" ]; then
        __PANEL__.property mode = "$2"
    else
        local val=$(__PANEL__.property mode)
        echo "${val:-navigation}"
    fi
}

__PANEL__.list_source(){
    if [ "$1" = "=" ]; then
        __PANEL__.property list_source = "$2"
    else
        local val=$(__PANEL__.property list_source)
        echo "${val:-__PANEL__.list}"
    fi
}

__PANEL__.in_archive(){
    if [ "$1" = "=" ]; then
        __PANEL__.property in_archive = "$2"
    else
        local val=$(__PANEL__.property in_archive)
        echo "${val:-0}"
    fi
}
# Array for pre-rendered file rows (cached for performance)
declare -ag __PANEL___rendered_rows=()

# Render a single file row to a string (with escape codes)
# Args: file_index
__PANEL__.render_row_string(){
    local file_idx=$1
    local width=$(__PANEL__.width)
    local active=$(__PANEL__.active)

    # Get active list (filelist or archivelist)
    local list=$(__PANEL__.list_source)
    local selected=$($list.selected)

    # Get item data from list (now includes link_target)
    local filename item_type item_size item_time is_exec is_marked link_target
    IFS='|' read -r filename item_type item_size item_time is_exec is_marked link_target <<< "$($list.get $file_idx)"

    # Calculate column widths
    local time_col_width=17
    local size_col_width=9
    local name_col_width=$((width - time_col_width - size_col_width - 2))

    # Set prefix character
    local prefix=" "
    if [ -n "$link_target" ]; then
        prefix="~"  # Symlink gets ~ prefix
    elif [ "$item_type" = "d" ]; then
        prefix="/"
    elif [ "$is_exec" = "1" ]; then
        prefix="*"
    fi

    local display_name="$filename"

    # Truncate display name if needed
    local max_filename_len=$((name_col_width - 1))
    if [ ${#display_name} -gt $max_filename_len ]; then
        display_name="${display_name:0:$((max_filename_len - 3))}..."
    fi

    # Pad display name
    local padding_needed=$((max_filename_len - ${#display_name}))
    local padding=""
    if [ $padding_needed -gt 0 ]; then
        padding=$(printf '%*s' "$padding_needed" "")
    fi

    # Determine highlight state
    local is_cursor=0
    local is_marked_file=0
    if [ $file_idx -eq $selected ] && [ $active -eq 1 ]; then
        is_cursor=1
    fi
    if [ "$is_marked" = "1" ]; then
        is_marked_file=1
    fi

    # Build row string using _PC_ variables (avoids subshell per call - see top of file)
    local row=""

    # Background
    if [ $is_cursor -eq 1 ]; then
        row+="$_PC_BG_CYAN"
    else
        row+="$_PC_BG_BLUE"
    fi

    # Name column
    if [ $is_cursor -eq 1 ]; then
        row+="$_PC_BLACK"
    elif [ $is_marked_file -eq 1 ]; then
        row+="$_PC_YELLOW$_PC_BOLD"
    elif [ "$item_type" = "d" ]; then
        row+="$_PC_WHITE$_PC_BOLD"
    elif [ "$is_exec" = "1" ]; then
        row+="$_PC_BRIGHT_GREEN"
    else
        row+="$_PC_WHITE"
    fi
    row+="${prefix}${display_name}${padding}"

    # First separator
    if [ $is_cursor -eq 1 ]; then
        row+="$_PC_BLACK"
    else
        row+="$_PC_REGULAR$_PC_WHITE"
    fi
    row+="│"

    # Size column
    if [ $is_cursor -eq 1 ]; then
        row+="$_PC_BLACK"
    elif [ "$item_type" = "d" ]; then
        row+="$_PC_WHITE$_PC_BOLD"
    else
        row+="$_PC_WHITE"
    fi
    local display_time="${item_time:0:$time_col_width}"
    row+="$(printf "%${size_col_width}s" "$item_size")"

    # Second separator
    if [ $is_cursor -eq 1 ]; then
        row+="$_PC_BLACK"
    else
        row+="$_PC_REGULAR$_PC_WHITE"
    fi
    row+="│"

    # Time column
    if [ $is_cursor -eq 1 ]; then
        row+="$_PC_BLACK"
    elif [ "$item_type" = "d" ]; then
        row+="$_PC_WHITE$_PC_BOLD"
    else
        row+="$_PC_WHITE"
    fi
    row+="$(printf "%-${time_col_width}s" "$display_time")"
    row+="$_PC_RESET"

    echo "$row"
}

# Pre-render all file rows (called when directory loads or panel becomes active)
__PANEL__.prerender_all_rows(){
    local list=$(__PANEL__.list_source)
    local count=$($list.count)
    __PANEL___rendered_rows=()
    
    for ((i=0; i<count; i++)); do
        __PANEL___rendered_rows[$i]=$(__PANEL__.render_row_string $i)
    done
}

# Update a single pre-rendered row
__PANEL__.update_rendered_row(){
    local index=$1
    __PANEL___rendered_rows[$index]=$(__PANEL__.render_row_string $index)
}

# Toggle selection and move down
__PANEL__.toggle_selection_and_move(){
    local list=$(__PANEL__.list_source)
    
    # Get position before toggle
    local old_pos=$($list.selected)
    
    # Toggle selection
    $list.toggle_selection
    
    # Update the row that was toggled
    __PANEL__.update_rendered_row $old_pos
    
    # Move down
    __PANEL__.navigate DOWN
}

# Property accessors

# Publish current directory to broker (only when active and broker is set)
__PANEL__._publish_dir(){
    local active=$(__PANEL__.active)
    [ "$active" != "1" ] && return
    local broker=$(__PANEL__.message_broker)
    [ -z "$broker" ] && return
    declare -F "$broker.publish" &>/dev/null || return
    # In archive mode, publish path to archive file itself
    local in_archive=$(__PANEL__.in_archive)
    local path
    if [ "$in_archive" = "1" ]; then
        path=$(__PANEL__.archive_path)
        path="${path%/*}"  # directory containing archive
    else
        local list=$(__PANEL__.list_source)
        path=$($list.path)
    fi
    "$broker.publish" "panel.active.dir_changed" "$path"
}

# Publish cursor moved (only when active and broker is set)
__PANEL__._publish_cursor_moved(){
    local active=$(__PANEL__.active)
    [ "$active" != "1" ] && return
    local broker=$(__PANEL__.message_broker)
    [ -z "$broker" ] && return
    declare -F "$broker.publish" &>/dev/null || return
    "$broker.publish" "panel.cursor_moved" ""
}



# Draw info bar (filename or search field)
__PANEL__.draw_info_bar(){
    local x=$(__PANEL__.x)
    local y=$(__PANEL__.y)
    local width=$(__PANEL__.width)
    local height=$(__PANEL__.height)
    local active=$(__PANEL__.active)
    local list=$(__PANEL__.list_source)
    
    local separator_row=$((y + height - 2))
    local selected=$($list.selected)
    local count=$($list.count)
    
    # Build separator line as string
    local separator_line=""
    
    # Get marked file stats for selection message
    local selected_count=$($list.count_selected)
    local total_bytes=$($list.marked_size)
    
    if [ $selected_count -gt 0 ]; then
        # Format total size
        local size_str
        if [ $total_bytes -lt 1024 ]; then
            size_str="${total_bytes}B"
        elif [ $total_bytes -lt 1048576 ]; then
            size_str="$((total_bytes / 1024))KB"
        else
            size_str="$((total_bytes / 1048576))MB"
        fi
        
        # Create message
        local msg=" ${size_str} in ${selected_count} files "
        local msg_len=${#msg}
        local left_dash=$(( (width - msg_len) / 2 ))
        local right_dash=$(( width - msg_len - left_dash ))
        
        # Build separator with message
        separator_line="├"
        for ((i=0; i<left_dash; i++)); do
            separator_line+="─"
        done
        separator_line+="$msg"
        for ((i=0; i<right_dash; i++)); do
            separator_line+="─"
        done
        separator_line+="┤"
    else
        # No selection - just draw horizontal line
        separator_line="├"
        for ((c=0; c<width; c++)); do
            separator_line+="─"
        done
        separator_line+="┤"
    fi
    
    # Draw separator in one go
    tui.cursor.move $separator_row $x
    tui.color.bg_blue
    tui.color.white
    printf '%s' "$separator_line"
    tui.style.reset
    
    # Build info bar line as string
    local info_line=""
    local mode=$(__PANEL__.mode)
    local search_text=$(__PANEL__.search_text)
    
    if [ "$mode" = "search" ] && [ $active -eq 1 ]; then
        # Show search field (only for active panel in search mode)
        local prompt="Search: "
        local display_text="$prompt$search_text"
        
        # Truncate if too long
        if [ ${#display_text} -gt $width ]; then
            local max_text=$((width - ${#prompt}))
            display_text="$prompt${search_text: -$max_text}"
        fi
        
        info_line=$(printf "%-${width}s" "$display_text")
        
        # Draw with cyan background
        tui.cursor.move $((separator_row + 1)) $((x + 1))
        tui.color.bg_cyan
        tui.color.black
        printf '%s' "$info_line"
    else
        # Show filename
        local selected_name=""
        if [ $count -gt 0 ]; then
            local fname ftype fsize ftime fexec fsel flink
            IFS='|' read -r fname ftype fsize ftime fexec fsel flink <<< "$($list.get $selected)"
            # For symlinks, show -> target, otherwise show filename
            if [ -n "$flink" ]; then
                selected_name="-> $flink"
            else
                selected_name="$fname"
            fi
        fi
        
        # Truncate if needed
        if [ ${#selected_name} -gt $width ]; then
            selected_name="${selected_name:0:$((width - 3))}..."
        fi
        
        info_line=$(printf "%-${width}s" "$selected_name")
        
        # Draw with blue background
        tui.cursor.move $((separator_row + 1)) $((x + 1))
        tui.color.bg_blue
        tui.color.white
        printf '%s' "$info_line"
    fi

    tui.style.reset
}

# Draw panel header with path
__PANEL__.draw_header(){
    local list=$(__PANEL__.list_source)
    local x=$(__PANEL__.x)
    local y=$(__PANEL__.y)
    local width=$(__PANEL__.width)
    local active=$(__PANEL__.active)
    local path=$($list.path)
    
    # Draw header with path
    tui.cursor.move $((y - 1)) $((x + 2))
    
    if [ $active -eq 1 ]; then
        # Active panel: cyan/bold header
        tui.style.bold
        tui.color.cyan
    else
        # Inactive panel: white on blue (matches panel background)
        tui.color.bg_blue
        tui.color.white
    fi
    
    # Truncate path if needed
    local max_path_len=$((width - 4))
    local display_path="$path"
    if [ ${#path} -gt $max_path_len ]; then
        display_path="...${path: -$((max_path_len - 3))}"
    fi
    printf " %s " "$display_path"
    tui.style.reset
}

# Render panel
__PANEL__.render(){
    tui.cursor.hide

    local list=$(__PANEL__.list_source)
    local x=$(__PANEL__.x)
    local y=$(__PANEL__.y)
    local width=$(__PANEL__.width)
    local height=$(__PANEL__.height)
    local active=$(__PANEL__.active)
    
    # Get filelist data
    local path=$($list.path)
    local selected=$($list.selected)
    local scroll=$($list.scroll)
    
    # Fill panel area with blue background (only the panel's area, not whole screen)
    for ((r=y-1; r<=y+height; r++)); do
        tui.cursor.move $r $x
        tui.color.bg_blue
        printf "%$((width + 2))s" ""
        tui.style.reset
    done
    
    # Set colors for border and draw it
    tui.color.bg_blue
    tui.color.white
    tui.box.draw $((y - 1)) $x $((width + 2)) $((height + 2))
    tui.style.reset
    
    # Draw header
    __PANEL__.draw_header
    
    # Draw column headers (bright yellow on blue, like MC)
    # Layout: Name (fills left) │ Size (9 chars) │ Modify time (17 chars at right edge)
    tui.cursor.move $y $((x + 1))
    tui.color.bg_blue
    local time_col_width=17
    local size_col_width=9
    local name_col_width=$((width - time_col_width - size_col_width - 2))  # -2 for separators
    
    # Get current sort order (skip for archives - they don't support sorting)
    local sort_order="name_asc"  # default
    local in_archive=$(__PANEL__.in_archive)
    if [ "$in_archive" != "1" ]; then
        local list=$(__PANEL__.list_source)
        sort_order=$($list.sort_order)
    fi
    local name_indicator=""
    local size_indicator=""
    local time_indicator=""
    
    # MC convention: ' for ascending, . for descending
    # Extension uses '_ and ._ to differentiate from name
    case "$sort_order" in
        name_asc)  name_indicator=" '" ;;
        name_desc) name_indicator=" ." ;;
        size_asc)  size_indicator=" '" ;;
        size_desc) size_indicator=" ." ;;
        date_asc)  time_indicator=" '" ;;
        date_desc) time_indicator=" ." ;;
        ext_asc)   name_indicator=" '_" ;;
        ext_desc)  name_indicator=" ._" ;;
    esac
    
    # Print Name header in bright yellow
    tui.color.bright_yellow
    local name_text="Name${name_indicator}"
    printf "%-${name_col_width}s" "${name_text:0:$name_col_width}"
    tui.style.reset
    tui.color.bg_blue
    tui.color.white
    printf "│"
    
    # Print Size header in bright yellow
    tui.color.bright_yellow
    local size_text="Size${size_indicator}"
    printf "%${size_col_width}s" "${size_text:0:$size_col_width}"
    tui.style.reset
    tui.color.bg_blue
    tui.color.white
    printf "│"
    
    # Print Modify time header in bright yellow
    tui.color.bright_yellow
    local time_text="Modify time${time_indicator}"
    printf "%-${time_col_width}s" "${time_text:0:$time_col_width}"
    tui.style.reset
    
    # Get file count
    local count=$($list.count)
    
    # Draw rows from pre-rendered cache
    local max_visible=$((height - 3))
    for ((i=0; i<max_visible; i++)); do
        local file_idx=$((scroll + i))
        
        if [ $file_idx -ge $count ]; then
            # Fill empty rows with blue background and column separators
            tui.cursor.move $((y + 1 + i)) $((x + 1))

            # Build empty row as string
            local empty_row="$_PC_BG_BLUE"
            empty_row+="$(printf "%${name_col_width}s" "")"
            empty_row+="$_PC_WHITE"
            empty_row+="│"
            empty_row+="$(printf "%${size_col_width}s" "")"
            empty_row+="│"
            empty_row+="$(printf "%${time_col_width}s" "")"
            empty_row+="$_PC_RESET"

            # Print in one go
            printf '%b' "$empty_row"
        else
            # Draw pre-rendered row
            tui.cursor.move $((y + 1 + i)) $((x + 1))
            printf '%b' "${__PANEL___rendered_rows[$file_idx]}"
        fi
    done

    # Draw info bar (includes separator)
    __PANEL__.draw_info_bar

    tui.cursor.hide
}

# Quick search - interactive search mode with its own input loop
__PANEL__.quick_search(){
    local list=$(__PANEL__.list_source)
    
    # Enter search mode
    __PANEL__.mode = "search"
    __PANEL__.search_text = ""
    
    # Save original position
    local original_selected=$($list.selected)
    local original_scroll=$($list.scroll)
    
    # Redraw panel to show search field
    __PANEL__.render
    
    # Input loop for search
    while true; do
        local key
        key=$(tui.input.key 2>&1) || {
            continue
        }
        local search_text=$(__PANEL__.search_text)
        
        case "$key" in
            ENTER|ESC)
                # Exit search mode
                __PANEL__.mode = "navigation"
                __PANEL__.search_text = ""
                
                # Just redraw the bottom filename bar (not whole panel)
                local x=$(__PANEL__.x)
                local y=$(__PANEL__.y)
                local height=$(__PANEL__.height)
                local width=$(__PANEL__.width)
                
                # Get selected filename
                local selected=$($list.selected)
                local selected_name=""
                local count=$($list.count)
                
                if [ $count -gt 0 ]; then
                    local fname ftype fsize ftime fexec fsel
                    IFS='|' read -r fname ftype fsize ftime fexec fsel <<< "$($list.get $selected)"
                    selected_name="$fname"
                fi
                
                # Draw filename bar
                local separator_row=$((y + height - 2))
                tui.cursor.move $((separator_row + 1)) $((x + 1))
                tui.color.bg_blue
                tui.color.white
                
                # Truncate if needed
                if [ ${#selected_name} -gt $width ]; then
                    selected_name="${selected_name:0:$((width - 3))}..."
                fi
                
                printf "%-${width}s" "$selected_name"
                tui.style.reset
                
                return 0
                ;;
            BACKSPACE)
                # Remove last character
                if [ ${#search_text} -gt 0 ]; then
                    # Remember current position
                    local old_pos=$($list.selected)
                    
                    search_text="${search_text:0:${#search_text}-1}"
                    __PANEL__.search_text = "$search_text"
                    
                    # Search from beginning if text remains, else restore original position
                    if [ -n "$search_text" ]; then
                        __PANEL__._do_search "$search_text" || true
                    else
                        $list.selected = $original_selected
                        $list.scroll = $original_scroll
                        
                        # Re-render affected rows
                        local new_pos=$($list.selected)
                        if [ $old_pos -ne $new_pos ]; then
                            __PANEL___rendered_rows[$old_pos]=$(__PANEL__.render_row_string $old_pos)
                            __PANEL___rendered_rows[$new_pos]=$(__PANEL__.render_row_string $new_pos)
                        fi
                    fi
                    
                    __PANEL__.render
                fi
                ;;
            *)
                # Regular character - add to search
                if [ ${#key} -eq 1 ] && [[ $key != $'\x1b' ]] && [[ $key != $'\x00' ]]; then
                    search_text="${search_text}${key}"
                    __PANEL__.search_text = "$search_text"
                    
                    # Perform search from beginning (ignore if not found)
                    __PANEL__._do_search "$search_text" || true
                    
                    __PANEL__.render
                fi
                ;;
        esac
    done
}

# Internal search function - finds first matching file from beginning
__PANEL__._do_search(){
    local list=$(__PANEL__.list_source)
    local search_text="$1"
    
    if [ -z "$search_text" ]; then
        return
    fi
    
    local file_count=$($list.count)
    
    local height=$(__PANEL__.height)
    local max_visible=$((height - 3))
    
    # Remember old cursor position
    local old_selected=$($list.selected)
    
    # Search from beginning (index 0) to find first match
    for ((i=0; i<file_count; i++)); do
        local fname ftype fsize ftime fexec fsel
        IFS='|' read -r fname ftype fsize ftime fexec fsel <<< "$($list.get $i)"
        
        # Case-insensitive prefix match
        if [[ "${fname,,}" == "${search_text,,}"* ]]; then
            $list.selected = $i
            
            # Adjust scroll to show selected item
            local scroll=$($list.scroll)
            
            if [ $i -ge $((scroll + max_visible)) ]; then
                $list.scroll = $((i - max_visible + 1))
            elif [ $i -lt $scroll ]; then
                $list.scroll = $i
            fi
            
            # Re-render the 2 affected rows
            if [ $old_selected -ne $i ]; then
                __PANEL___rendered_rows[$old_selected]=$(__PANEL__.render_row_string $old_selected)
                __PANEL___rendered_rows[$i]=$(__PANEL__.render_row_string $i)
            fi
            
            return 0
        fi
    done
    
    return 1
}


# Navigate in the panel (UP, DOWN, PAGEUP, PAGEDOWN, HOME, END)
__PANEL__.navigate(){
    local list=$(__PANEL__.list_source)
    local direction="$1"
    local height=$(__PANEL__.height)
    local max_visible=$((height - 3))

    # Get old cursor position
    local old_selected=$($list.selected)
    local old_scroll=$($list.scroll)

    # Navigate (updates cursor position)
    $list.navigate "$direction" $max_visible

    # Get new cursor position
    local new_selected=$($list.selected)
    local new_scroll=$($list.scroll)

    # If nothing changed, don't redraw
    if [ $old_selected -eq $new_selected ] && [ $old_scroll -eq $new_scroll ]; then
        return
    fi

    tui.cursor.hide

    # Hoist panel geometry - used in all branches below
    local x=$(__PANEL__.x)
    local y=$(__PANEL__.y)
    local width=$(__PANEL__.width)
    local count=$($list.count)
    local scroll_delta=$((new_scroll - old_scroll))

    # Update pre-rendered cache for rows whose highlight state changed
    if [ $old_selected -ne $new_selected ]; then
        __PANEL___rendered_rows[$old_selected]=$(__PANEL__.render_row_string $old_selected)
        __PANEL___rendered_rows[$new_selected]=$(__PANEL__.render_row_string $new_selected)
    fi

    if [ $scroll_delta -eq 1 ] || [ $scroll_delta -eq -1 ]; then
        # Scrolled by one line - redraw all visible rows at their new positions
        for ((i=0; i<max_visible; i++)); do
            local file_idx=$((new_scroll + i))
            tui.cursor.move $((y + 1 + i)) $((x + 1))
            if [ $file_idx -ge $count ]; then
                local time_col_width=17
                local size_col_width=9
                local name_col_width=$((width - time_col_width - size_col_width - 2))
                local empty_row
                empty_row="$_PC_BG_BLUE"
                empty_row+="$(printf "%${name_col_width}s" "")"
                empty_row+="$_PC_WHITE"
                empty_row+="│$(printf "%${size_col_width}s" "")│$(printf "%${time_col_width}s" "")"
                empty_row+="$_PC_RESET"
                printf '%b' "$empty_row"
            else
                printf '%b' "${__PANEL___rendered_rows[$file_idx]}"
            fi
        done

        __PANEL__.draw_info_bar

    elif [ $old_scroll -ne $new_scroll ]; then
        # Scroll changed by more than 1 (page up/down, home/end) - full redraw
        __PANEL__.render

    else
        # No scroll change - just redraw the 2 affected rows
        local old_visible_row=$((old_selected - old_scroll))
        if [ $old_visible_row -ge 0 ] && [ $old_visible_row -lt $max_visible ]; then
            tui.cursor.move $((y + 1 + old_visible_row)) $((x + 1))
            printf '%b' "${__PANEL___rendered_rows[$old_selected]}"
        fi

        local new_visible_row=$((new_selected - new_scroll))
        if [ $new_visible_row -ge 0 ] && [ $new_visible_row -lt $max_visible ]; then
            tui.cursor.move $((y + 1 + new_visible_row)) $((x + 1))
            printf '%b' "${__PANEL___rendered_rows[$new_selected]}"
        fi

        __PANEL__.draw_info_bar
    fi

    __PANEL__._publish_cursor_moved
}

# Get selected item info
# Returns: filename|filetype|path
__PANEL__.get_selected_item(){
    local list=$(__PANEL__.list_source)
    
    local selected=$($list.selected)
    local filename filetype fsize ftime fexec fsel path
    
    IFS='|' read -r filename filetype fsize ftime fexec fsel <<< "$($list.get $selected)"
    path=$($list.path)
    
    echo "$filename|$filetype|$path"
}

# Reload panel's filelist from disk (re-scans current directory to pick up changes)
__PANEL__.reload(){
    local list=$(__PANEL__.list_source)
    
    # Save current position before reload
    local saved_position=$($list.selected)
    
    # Reload the list (resets selected and scroll to 0)
    $list.load
    
    # Restore and clamp position
    local count=$($list.count)
    if [ $saved_position -ge $count ] && [ $count -gt 0 ]; then
        saved_position=$((count - 1))
    fi
    $list.selected = $saved_position
    
    # Adjust scroll to keep selection visible
    local height=$(__PANEL__.height)
    local max_visible=$((height - 3))
    local scroll=0  # load resets scroll to 0
    
    if [ $saved_position -lt $scroll ]; then
        $list.scroll = $saved_position
    elif [ $saved_position -ge $max_visible ]; then
        $list.scroll = $((saved_position - max_visible + 1))
    fi
    
    # Re-render with correct position
    __PANEL__.prerender_all_rows
}

# Check if filename is an archive
# Enter archive view mode
__PANEL__._enter_archive(){
    local list=$(__PANEL__.list_source)
    local archive_file="$1"
    local archive_fullpath="$($list.path)/$archive_file"

    tui.cursor.hide

    # Show status dialog if dialog instance is set
    local dlg=$(__PANEL__.dialog)
    if [ -n "$dlg" ] && declare -F "$dlg.show_status" &>/dev/null; then
        local px=$(__PANEL__.x)
        local py=$(__PANEL__.y)
        local pw=$(__PANEL__.width)
        local ph=$(__PANEL__.height)
        "$dlg.show_status" "Opening Archive" "Opening archive $archive_file..." "$px" "$py" "$pw" "$ph"
    fi

    # Create archivelist object as a separate object
    archivelist __PANEL__.archive_list || return 1

    # Initialize archive (archive_path setter auto-detects archive_type)
    __PANEL__.archive_list.archive_path = "$archive_fullpath" || return 1
    __PANEL__.archive_list.internal_path = "" || return 1
    __PANEL__.archive_list.load || return 1

    # Mark panel as in archive mode
    __PANEL__.in_archive = 1
    __PANEL__.archive_path = "$archive_fullpath"
    __PANEL__.list_source = "__PANEL__.archive_list"

    # Pre-render
    __PANEL__.prerender_all_rows || return 1
}

# Exit archive view mode
__PANEL__._exit_archive(){
    local saved_archive_path=$(__PANEL__.archive_path)
    local archive_dir="${saved_archive_path%/*}"
    local archive_file="${saved_archive_path##*/}"
    
    # Get archive list before switching
    local archive_list=$(__PANEL__.list_source)
    
    # Tell archivelist to clean up
    if [ "$archive_list" != "__PANEL__.list" ]; then
        $archive_list.cleanup
    fi
    
    # Switch back to filelist
    __PANEL__.list_source = "__PANEL__.list"
    
    # Now get the correct list (filelist, not archivelist)
    local list=$(__PANEL__.list_source)
    
    # Load the directory containing the archive
    $list.path = "$archive_dir"
    cd "$archive_dir" 2>/dev/null || true
    
    # Find and select the archive file
    local height=$(__PANEL__.height)
    local visible_rows=$((height - 3))
    $list.find_and_select "$archive_file" $visible_rows
    
    # Clear archive mode flags
    __PANEL__.in_archive = 0
    __PANEL__.archive_path = ""

    # Pre-render
    __PANEL__.prerender_all_rows
}

# Handle ENTER key - navigate into directory or set result for file opening
__PANEL__.enter(){
    local list=$(__PANEL__.list_source)
    local filename filetype path
    IFS='|' read -r filename filetype path <<< "$(__PANEL__.get_selected_item)"
    
    local in_archive=$(__PANEL__.in_archive)
    
    # Check if we're at root of archive and pressing .. (exit archive)
    if [ "$in_archive" = "1" ] && [ "$filename" = ".." ]; then
        # Check if we're at archive root
        local internal=$($list.internal_path)
        if [ -z "$internal" ]; then
            # Exit archive mode
            __PANEL__._exit_archive
            __PANEL__.render
            __PANEL__._publish_dir
            __PANEL__.enter_result = "ok"
            return
        fi
    fi
    
    # If in archive mode, delegate to archivelist.enter
    if [ "$in_archive" = "1" ]; then
        if [ "$filetype" = "d" ]; then
            local list=$(__PANEL__.list_source)
            
            $list.enter
            
            # If we went up (..), adjust scroll properly
            if [ "$filename" = ".." ]; then
                # Get the now-selected item (directory we just left)
                local selected_info
                IFS='|' read -r selected_filename selected_type selected_path <<< "$($list.get_selected_item)"
                
                # Adjust scroll using panel's actual height
                local height=$(__PANEL__.height)
                local visible_rows=$((height - 3))
                $list.find_and_select "$selected_filename" $visible_rows
            fi
            
            __PANEL__.prerender_all_rows
            __PANEL__.render
            __PANEL__.enter_result = "ok"
        elif [ "$filetype" = "f" ]; then
            # TODO: Extract file from archive for viewing
            __PANEL__.enter_result = "archive_file:$filename"
        fi
        return
    fi
    
    local list_type=$($list.type)

    if [ "$filename" = "<empty>" ]; then
        __PANEL__.enter_result = ""
    elif [ "$filetype" = "d" ]; then
        # Directory navigation - works the same regardless of list type
        if [ "$filename" = ".." ]; then
            local current_dir="${path##*/}"
            local parent_dir="${path%/*}"
            [ -z "$parent_dir" ] && parent_dir="/"

            $list.path = "$parent_dir"
            cd "$parent_dir" 2>/dev/null || true

            local height=$(__PANEL__.height)
            local visible_rows=$((height - 3))
            $list.find_and_select "$current_dir" $visible_rows
            __PANEL__.prerender_all_rows
        else
            local new_path
            if [ "$path" = "/" ]; then
                new_path="/$filename"
            else
                new_path="$path/$filename"
            fi
            $list.path = "$new_path"
            cd "$new_path" 2>/dev/null || true
            __PANEL__.prerender_all_rows
        fi

        __PANEL__.render
        __PANEL__._publish_dir
        __PANEL__.enter_result = "ok"
    elif [ "$filetype" = "f" ] && [ "$list_type" = "filesystem" ]; then
        local filepath="$path/$filename"
        local ext="${filename##*.}"
        ext="${ext,,}"

        # Check ext.conf first - takes precedence over archive browsing and executable bit
        local handler=""
        local ext_conf="$HACKFM_DIR/conf/ext.conf"
        if [ -f "$ext_conf" ]; then
            while IFS=' ' read -r conf_ext conf_cmd || [ -n "$conf_ext" ]; do
                [ -z "$conf_ext" ] || [[ "$conf_ext" == \#* ]] && continue
                if [ "${conf_ext,,}" = "$ext" ]; then
                    handler="$conf_cmd"
                    break
                fi
            done < "$ext_conf"
        fi

        if [ -n "$handler" ] && command -v "${handler%% *}" &>/dev/null; then
            # ext.conf handler found - open with it, skip archive probe and executable check
            __PANEL__.enter_result = "open:$filepath"
        else
            # No ext.conf handler - check if it's an archive
            local probe_type
            archivelist __PANEL__.archive_list
            __PANEL__.archive_list.archive_path = "$path/$filename"
            probe_type=$(__PANEL__.archive_list.archive_type)

            if [ -n "$probe_type" ]; then
                # archive_path setter recognised the extension - enter archive mode
                __PANEL__._enter_archive "$filename"
                __PANEL__.render
                __PANEL__._publish_dir
                __PANEL__.enter_result = "ok"
            elif [ -x "$filepath" ]; then
                # Executable file - run it
                __PANEL__.enter_result = "execute:$filepath"
            else
                # Plain file - no handler, not an archive, not executable
                __PANEL__.enter_result = ""
            fi
        fi
    else
        __PANEL__.enter_result = ""
    fi
}

