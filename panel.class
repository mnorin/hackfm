#!/bin/bash
# panel.class - File panel using ba.sh

__PANEL___properties=()

__PANEL__.property(){
    # Property indices
    local x=0
    local y=1
    local width=2
    local height=3
    local active=4
    local search_text=5
    local mode=6  # "navigation" or "search"
    local enter_result=7  # Result of last enter operation
    local list_source=8  # Name of list object (filelist or archivelist instance)
    local in_archive=9  # 1 if viewing archive, 0 if normal filesystem
    local archive_path=10  # Path to archive file being viewed
    
    if [ "$2" = "=" ]; then
        __PANEL___properties[$1]="$3"
    else
        echo "${__PANEL___properties[$1]}"
    fi
}

# Array for pre-rendered file rows (cached for performance)
declare -ag __PANEL___rendered_rows=()

# Render a single file row to a string (with escape codes)
# Args: file_index
__PANEL__.render_row_string(){
    local file_idx=$1
    local width=$(__PANEL__.width)
    local active=$(__PANEL__.active)
    
    # Get active list (filelist or archivelist)
    local list=$(__PANEL__.list_source)
    local selected=$($list.selected)
    
    # Get item data from list (now includes link_target)
    local filename item_type item_size item_time is_exec is_marked link_target
    IFS='|' read -r filename item_type item_size item_time is_exec is_marked link_target <<< "$($list.get $file_idx)"
    
    # Calculate column widths
    local time_col_width=17
    local size_col_width=9
    local name_col_width=$((width - time_col_width - size_col_width - 2))
    
    # Set prefix character
    local prefix=" "
    if [ -n "$link_target" ]; then
        prefix="~"  # Symlink gets ~ prefix
    elif [ "$item_type" = "d" ]; then
        prefix="/"
    elif [ "$is_exec" = "1" ]; then
        prefix="*"
    fi
    
    # For symlinks, just use ~ prefix, no -> target in the column
    local display_name="$filename"
    
    # Truncate display name if needed
    local max_filename_len=$((name_col_width - 1))
    if [ ${#display_name} -gt $max_filename_len ]; then
        display_name="${display_name:0:$((max_filename_len - 3))}..."
    fi
    
    # Pad display name
    local filename_visual_len=${#display_name}
    local padding_needed=$((max_filename_len - filename_visual_len))
    local padding=""
    if [ $padding_needed -gt 0 ]; then
        padding=$(printf '%*s' "$padding_needed" "")
    fi
    
    # Build row string with escape codes
    local row="\033[44m"  # Blue background
    
    # Name column color
    if [ $file_idx -eq $selected ] && [ $active -eq 1 ]; then
        row+="\033[46m\033[30m\033[1m"  # Cyan bg, black, bold
    elif [ "$is_marked" = "1" ]; then
        row+="\033[44m\033[33m\033[1m"  # Blue bg, yellow, bold
    else
        if [ "$item_type" = "d" ]; then
            row+="\033[37m\033[1m"  # White, bold
        elif [ "$is_exec" = "1" ]; then
            row+="\033[92m"  # Bright green
        else
            row+="\033[97m"  # Bright white
        fi
    fi
    row+="${prefix}${display_name}${padding}"
    
    # Separator and columns
    row+="\033[0m\033[44m\033[97m"
    local display_time="${item_time:0:$time_col_width}"
    row+="│$(printf "%${size_col_width}s" "$item_size")│$(printf "%-${time_col_width}s" "$display_time")"
    row+="\033[0m"
    
    echo "$row"
}

# Pre-render all file rows (called when directory loads or panel becomes active)
__PANEL__.prerender_all_rows(){
    local list=$(__PANEL__.list_source)
    local list=$(__PANEL__.list_source)
    local count=$($list.count)
    __PANEL___rendered_rows=()
    
    for ((i=0; i<count; i++)); do
        __PANEL___rendered_rows[$i]=$(__PANEL__.render_row_string $i)
    done
}

# Property accessors
__PANEL__.x(){
    if [ "$1" = "=" ]; then
        __PANEL__.property x = "$2"
    else
        __PANEL__.property x
    fi
}

__PANEL__.y(){
    if [ "$1" = "=" ]; then
        __PANEL__.property y = "$2"
    else
        __PANEL__.property y
    fi
}

__PANEL__.width(){
    if [ "$1" = "=" ]; then
        __PANEL__.property width = "$2"
    else
        __PANEL__.property width
    fi
}

__PANEL__.height(){
    if [ "$1" = "=" ]; then
        __PANEL__.property height = "$2"
    else
        __PANEL__.property height
    fi
}

__PANEL__.active(){
    if [ "$1" = "=" ]; then
        local old_value=$(__PANEL__.property active)
        __PANEL__.property active = "$2"
        # Auto-render when active status changes
        if [ "$old_value" != "$2" ]; then
            # Pre-render all rows with new active status
            __PANEL__.prerender_all_rows
            __PANEL__.render
            # Also cd to this panel's directory when becoming active
            if [ "$2" = "1" ]; then
                local list=$(__PANEL__.list_source)
                local path=$($list.path)
                cd "$path" 2>/dev/null || true
            fi
        fi
    else
        __PANEL__.property active
    fi
}

__PANEL__.search_text(){
    if [ "$1" = "=" ]; then
        __PANEL__.property search_text = "$2"
    else
        __PANEL__.property search_text
    fi
}

__PANEL__.mode(){
    if [ "$1" = "=" ]; then
        __PANEL__.property mode = "$2"
    else
        local val=$(__PANEL__.property mode)
        echo "${val:-navigation}"
    fi
}

__PANEL__.enter_result(){
    if [ "$1" = "=" ]; then
        __PANEL__.property enter_result = "$2"
    else
        __PANEL__.property enter_result
    fi
}

__PANEL__.list_source(){
    if [ "$1" = "=" ]; then
        __PANEL__.property list_source = "$2"
    else
        local val=$(__PANEL__.property list_source)
        # Default to .list if not set
        echo "${val:-__PANEL__.list}"
    fi
}

__PANEL__.in_archive(){
    if [ "$1" = "=" ]; then
        __PANEL__.property in_archive = "$2"
    else
        local val=$(__PANEL__.property in_archive)
        echo "${val:-0}"
    fi
}

__PANEL__.archive_path(){
    if [ "$1" = "=" ]; then
        __PANEL__.property archive_path = "$2"
    else
        __PANEL__.property archive_path
    fi
}

# Render method
__PANEL__.render(){
    # Hide cursor during rendering to reduce artifacts
    tui.cursor.hide
    
    local list=$(__PANEL__.list_source)
    local debug_path=$($list.path)
    local x=$(__PANEL__.x)
    local y=$(__PANEL__.y)
    local width=$(__PANEL__.width)
    local height=$(__PANEL__.height)
    local active=$(__PANEL__.active)
    
    # Get filelist data
    local path=$($list.path)
    local selected=$($list.selected)
    local scroll=$($list.scroll)
    
    # Fill panel area with blue background (only the panel's area, not whole screen)
    for ((r=y-1; r<=y+height; r++)); do
        tui.cursor.move $r $x
        tui.color.bg_blue
        printf "%$((width + 2))s" ""
        tui.color.reset
    done
    
    # Set colors for border and draw it
    tui.color.bg_blue
    tui.color.white
    tui.box.draw $((y - 1)) $x $((width + 2)) $((height + 2))
    tui.color.reset
    
    # Draw header with path
    tui.cursor.move $((y - 1)) $((x + 2))
    
    if [ $active -eq 1 ]; then
        # Active panel: cyan/bold header
        tui.color.bold
        tui.color.cyan
    else
        # Inactive panel: white on blue (matches panel background)
        tui.color.bg_blue
        tui.color.white
    fi
    
    # Truncate path if needed
    local max_path_len=$((width - 4))
    local display_path="$path"
    if [ ${#path} -gt $max_path_len ]; then
        display_path="...${path: -$((max_path_len - 3))}"
    fi
    printf " %s " "$display_path"
    tui.color.reset
    
    # Draw column headers (bright yellow on blue, like MC)
    # Layout: Name (fills left) │ Size (9 chars) │ Modify time (17 chars at right edge)
    tui.cursor.move $y $((x + 1))
    tui.color.bg_blue
    local time_col_width=17
    local size_col_width=9
    local name_col_width=$((width - time_col_width - size_col_width - 2))  # -2 for separators
    
    # Get current sort order (skip for archives - they don't support sorting)
    local sort_order="name_asc"  # default
    local in_archive=$(__PANEL__.in_archive)
    if [ "$in_archive" != "1" ]; then
        local list=$(__PANEL__.list_source)
        sort_order=$($list.sort_order)
    fi
    local name_indicator=""
    local size_indicator=""
    local time_indicator=""
    
    # MC convention: ' for ascending, . for descending
    # Extension uses '_ and ._ to differentiate from name
    case "$sort_order" in
        name_asc)  name_indicator=" '" ;;
        name_desc) name_indicator=" ." ;;
        size_asc)  size_indicator=" '" ;;
        size_desc) size_indicator=" ." ;;
        date_asc)  time_indicator=" '" ;;
        date_desc) time_indicator=" ." ;;
        ext_asc)   name_indicator=" '_" ;;
        ext_desc)  name_indicator=" ._" ;;
    esac
    
    # Print Name header in bright yellow
    tui.color.bright_yellow
    local name_text="Name${name_indicator}"
    printf "%-${name_col_width}s" "${name_text:0:$name_col_width}"
    tui.color.reset
    tui.color.bg_blue
    tui.color.bright_white
    printf "│"
    
    # Print Size header in bright yellow
    tui.color.bright_yellow
    local size_text="Size${size_indicator}"
    printf "%${size_col_width}s" "${size_text:0:$size_col_width}"
    tui.color.reset
    tui.color.bg_blue
    tui.color.bright_white
    printf "│"
    
    # Print Modify time header in bright yellow
    tui.color.bright_yellow
    local time_text="Modify time${time_indicator}"
    printf "%-${time_col_width}s" "${time_text:0:$time_col_width}"
    tui.color.reset
    
    # Draw files - start one row down to account for header
    local row=$((y + 1))
    
    # Get file count from filelist
    local count=$($list.count)
    
    # Print pre-rendered rows (much faster!)
    for ((i=scroll; i<scroll+height-3 && i<count; i++)); do
        tui.cursor.move $row $((x + 1))
        printf "%b" "${__PANEL___rendered_rows[$i]}"
        ((row++))
    done
    
    # Fill remaining rows with blue background and column separators
    local separator_row=$((y + height - 2))  # Two rows from bottom (separator + filename)
    while [ $row -lt $separator_row ]; do
        tui.cursor.move $row $((x + 1))
        tui.color.bg_blue
        tui.color.bright_white
        # Print empty space with column separators
        printf "%-${name_col_width}s│%${size_col_width}s│%-${time_col_width}s" "" "" ""
        tui.color.reset
        ((row++))
    done
    
    # Draw horizontal separator line with selection info
    tui.cursor.move $separator_row $((x + 1))
    tui.color.bg_blue
    tui.color.bright_white
    
    # Get marked file stats (fast - no loop needed!)
    local selected_count=$($list.count_selected)
    local total_bytes=$($list.marked_size)
    
    # Format total size
    local size_str
    if [ $total_bytes -lt 1024 ]; then
        size_str="${total_bytes}B"
    elif [ $total_bytes -lt 1048576 ]; then
        size_str="$((total_bytes / 1024))KB"
    else
        size_str="$((total_bytes / 1048576))MB"
    fi
    
    # Create message if files are selected
    if [ $selected_count -gt 0 ]; then
        local msg=" ${size_str} in ${selected_count} files "
        local msg_len=${#msg}
        local left_dash=$(( (width - msg_len) / 2 ))
        local right_dash=$(( width - msg_len - left_dash ))
        
        # Draw left dashes
        for ((i=0; i<left_dash; i++)); do
            printf '─'
        done
        
        # Draw message
        printf '%s' "$msg"
        
        # Draw right dashes
        for ((i=0; i<right_dash; i++)); do
            printf '─'
        done
    else
        # No selection - just draw line
        for ((i=0; i<width; i++)); do
            printf '─'
        done
    fi
    
    tui.color.reset
    
    # Draw filename bar at bottom showing selected item or search field
    tui.cursor.move $((separator_row + 1)) $((x + 1))
    
    local mode=$(__PANEL__.mode)
    local search_text=$(__PANEL__.search_text)
    
    if [ "$mode" = "search" ] && [ $active -eq 1 ]; then
        # Show search field (only for active panel in search mode)
        tui.color.bg_cyan
        tui.color.black
        
        local prompt="Search: "
        local display_text="$prompt$search_text"
        
        # Truncate if too long
        if [ ${#display_text} -gt $width ]; then
            local max_text=$((width - ${#prompt}))
            display_text="$prompt${search_text: -$max_text}"
        fi
        
        printf "%-${width}s" "$display_text"
    else
        # Show filename
        tui.color.bg_blue
        tui.color.bright_white
        
        # Get selected filename
        local selected_name=""
        if [ $count -gt 0 ]; then
            local fname ftype fsize ftime fexec fsel flink
            IFS='|' read -r fname ftype fsize ftime fexec fsel flink <<< "$($list.get $selected)"
            # For symlinks, show -> target, otherwise show filename
            if [ -n "$flink" ]; then
                selected_name="-> $flink"
            else
                selected_name="$fname"
            fi
        fi
        
        # Truncate if needed
        if [ ${#selected_name} -gt $width ]; then
            selected_name="${selected_name:0:$((width - 3))}..."
        fi
        
        printf "%-${width}s" "$selected_name"
    fi
    
    tui.color.reset
    tui.cursor.hide
}

# Quick search - interactive search mode with its own input loop
__PANEL__.quick_search(){
    local list=$(__PANEL__.list_source)
    
    # Enter search mode
    __PANEL__.mode = "search"
    __PANEL__.search_text = ""
    
    # Save original position
    local original_selected=$($list.selected)
    local original_scroll=$($list.scroll)
    
    # Redraw panel to show search field
    __PANEL__.render
    
    # Input loop for search
    while true; do
        local key
        key=$(tui.input.key 2>&1) || {
            continue
        }
        local search_text=$(__PANEL__.search_text)
        
        case "$key" in
            ENTER|ESC)
                # Exit search mode
                __PANEL__.mode = "navigation"
                __PANEL__.search_text = ""
                
                # Just redraw the bottom filename bar (not whole panel)
                local x=$(__PANEL__.x)
                local y=$(__PANEL__.y)
                local height=$(__PANEL__.height)
                local width=$(__PANEL__.width)
                
                # Get selected filename
                local selected=$($list.selected)
                local selected_name=""
                local count=$($list.count)
                
                if [ $count -gt 0 ]; then
                    local fname ftype fsize ftime fexec fsel
                    IFS='|' read -r fname ftype fsize ftime fexec fsel <<< "$($list.get $selected)"
                    selected_name="$fname"
                fi
                
                # Draw filename bar
                local separator_row=$((y + height - 2))
                tui.cursor.move $((separator_row + 1)) $((x + 1))
                tui.color.bg_blue
                tui.color.bright_white
                
                # Truncate if needed
                if [ ${#selected_name} -gt $width ]; then
                    selected_name="${selected_name:0:$((width - 3))}..."
                fi
                
                printf "%-${width}s" "$selected_name"
                tui.color.reset
                
                return 0
                ;;
            BACKSPACE)
                # Remove last character
                if [ ${#search_text} -gt 0 ]; then
                    # Remember current position
                    local old_pos=$($list.selected)
                    
                    search_text="${search_text:0:${#search_text}-1}"
                    __PANEL__.search_text = "$search_text"
                    
                    # Search from beginning if text remains, else restore original position
                    if [ -n "$search_text" ]; then
                        __PANEL__._do_search "$search_text" || true
                    else
                        $list.selected = $original_selected
                        $list.scroll = $original_scroll
                        
                        # Re-render affected rows
                        local new_pos=$($list.selected)
                        if [ $old_pos -ne $new_pos ]; then
                            __PANEL___rendered_rows[$old_pos]=$(__PANEL__.render_row_string $old_pos)
                            __PANEL___rendered_rows[$new_pos]=$(__PANEL__.render_row_string $new_pos)
                        fi
                    fi
                    
                    __PANEL__.render
                fi
                ;;
            *)
                # Regular character - add to search
                if [ ${#key} -eq 1 ] && [[ $key != $'\x1b' ]] && [[ $key != $'\x00' ]]; then
                    search_text="${search_text}${key}"
                    __PANEL__.search_text = "$search_text"
                    
                    # Perform search from beginning (ignore if not found)
                    __PANEL__._do_search "$search_text" || true
                    
                    __PANEL__.render
                fi
                ;;
        esac
    done
}

# Internal search function - finds first matching file from beginning
__PANEL__._do_search(){
    local list=$(__PANEL__.list_source)
    local search_text="$1"
    
    if [ -z "$search_text" ]; then
        return
    fi
    
    local file_count=$($list.count)
    
    local height=$(__PANEL__.height)
    local max_visible=$((height - 3))
    
    # Remember old cursor position
    local old_selected=$($list.selected)
    
    # Search from beginning (index 0) to find first match
    for ((i=0; i<file_count; i++)); do
        local fname ftype fsize ftime fexec fsel
        IFS='|' read -r fname ftype fsize ftime fexec fsel <<< "$($list.get $i)"
        
        # Case-insensitive prefix match
        if [[ "${fname,,}" == "${search_text,,}"* ]]; then
            $list.selected = $i
            
            # Adjust scroll to show selected item
            local scroll=$($list.scroll)
            
            if [ $i -ge $((scroll + max_visible)) ]; then
                $list.scroll = $((i - max_visible + 1))
            elif [ $i -lt $scroll ]; then
                $list.scroll = $i
            fi
            
            # Re-render the 2 affected rows
            if [ $old_selected -ne $i ]; then
                __PANEL___rendered_rows[$old_selected]=$(__PANEL__.render_row_string $old_selected)
                __PANEL___rendered_rows[$i]=$(__PANEL__.render_row_string $i)
            fi
            
            return 0
        fi
    done
    
    return 1
}

# Navigate in the panel (UP, DOWN, PAGEUP, PAGEDOWN, HOME, END)
__PANEL__.navigate(){
    local list=$(__PANEL__.list_source)
    local direction="$1"
    local height=$(__PANEL__.height)
    local max_visible=$((height - 3))
    
    # Get old cursor position
    local old_selected=$($list.selected)
    
    # Navigate (updates cursor position)
    $list.navigate "$direction" $max_visible
    
    # Get new cursor position
    local new_selected=$($list.selected)
    
    # Re-render only the 2 affected rows (old and new cursor positions)
    if [ $old_selected -ne $new_selected ]; then
        __PANEL___rendered_rows[$old_selected]=$(__PANEL__.render_row_string $old_selected)
        __PANEL___rendered_rows[$new_selected]=$(__PANEL__.render_row_string $new_selected)
        # Render panel to update display
        __PANEL__.render
    fi
    # If cursor didn't move, don't render anything
}

# Get selected item info
# Returns: filename|filetype|path
__PANEL__.get_selected_item(){
    local list=$(__PANEL__.list_source)
    
    local selected=$($list.selected)
    local filename filetype fsize ftime fexec fsel path
    
    IFS='|' read -r filename filetype fsize ftime fexec fsel <<< "$($list.get $selected)"
    path=$($list.path)
    
    echo "$filename|$filetype|$path"
}

# Reload panel's filelist from disk (re-scans current directory to pick up changes)
__PANEL__.reload(){
    local list=$(__PANEL__.list_source)
    $list.load
    __PANEL__.prerender_all_rows
}

# Check if filename is an archive
__PANEL__._is_archive(){
    local filename="$1"
    local lowercase="${filename,,}"  # Convert to lowercase
    case "$lowercase" in
        *.tar.gz|*.tgz|*.tar.bz2|*.tbz2|*.tar.xz|*.txz|*.tar|*.zip|*.rar|*.7z)
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

# Enter archive view mode
__PANEL__._enter_archive(){
    local list=$(__PANEL__.list_source)
    local archive_file="$1"
    local archive_fullpath="$($list.path)/$archive_file"
    
    # Detect archive type
    local archive_type
    case "$archive_file" in
        *.tar.gz|*.tgz)   archive_type="tar.gz" ;;
        *.tar.bz2|*.tbz2) archive_type="tar.bz2" ;;
        *.tar.xz|*.txz)   archive_type="tar.xz" ;;
        *.tar)            archive_type="tar" ;;
        *.zip)            archive_type="zip" ;;
        *.rar)            archive_type="rar" ;;
        *.7z|*.7Z)        archive_type="7z" ;;
    esac
    
    # Create archivelist object as a separate object
    archivelist __PANEL__.archive_list || return 1
    
    # Initialize archive
    __PANEL__.archive_list.archive_path = "$archive_fullpath" || return 1
    __PANEL__.archive_list.internal_path = "" || return 1
    __PANEL__.archive_list.archive_type = "$archive_type" || return 1
    __PANEL__.archive_list.load || return 1
    
    # Mark panel as in archive mode
    __PANEL__.in_archive = 1
    __PANEL__.archive_path = "$archive_fullpath"
    __PANEL__.list_source = "__PANEL__.archive_list"
    
    # Pre-render
    __PANEL__.prerender_all_rows || return 1
}

# Exit archive view mode
__PANEL__._exit_archive(){
    local saved_archive_path=$(__PANEL__.archive_path)
    local archive_dir="${saved_archive_path%/*}"
    local archive_file="${saved_archive_path##*/}"
    
    # Get archive list before switching
    local archive_list=$(__PANEL__.list_source)
    
    # Tell archivelist to clean up
    if [ "$archive_list" != "__PANEL__.list" ]; then
        $archive_list.cleanup
    fi
    
    # Switch back to filelist
    __PANEL__.list_source = "__PANEL__.list"
    
    # Now get the correct list (filelist, not archivelist)
    local list=$(__PANEL__.list_source)
    
    # Load the directory containing the archive
    $list.path = "$archive_dir"
    cd "$archive_dir" 2>/dev/null || true
    
    # Find and select the archive file
    local height=$(__PANEL__.height)
    local visible_rows=$((height - 3))
    $list.find_and_select "$archive_file" $visible_rows
    
    # Clear archive mode flags
    __PANEL__.in_archive = 0
    __PANEL__.archive_path = ""
    
    # Pre-render
    __PANEL__.prerender_all_rows
}

# Handle ENTER key - navigate into directory or set result for file opening
__PANEL__.enter(){
    local list=$(__PANEL__.list_source)
    local filename filetype path
    IFS='|' read -r filename filetype path <<< "$(__PANEL__.get_selected_item)"
    
    local in_archive=$(__PANEL__.in_archive)
    
    # Check if we're at root of archive and pressing .. (exit archive)
    if [ "$in_archive" = "1" ] && [ "$filename" = ".." ]; then
        # Check if we're at archive root
        local internal=$($list.internal_path)
        if [ -z "$internal" ]; then
            # Exit archive mode
            __PANEL__._exit_archive
            __PANEL__.render
            __PANEL__.enter_result = "ok"
            return
        fi
    fi
    
    # If in archive mode, delegate to archivelist.enter
    if [ "$in_archive" = "1" ]; then
        if [ "$filetype" = "d" ]; then
            local list=$(__PANEL__.list_source)
            
            $list.enter
            
            # If we went up (..), adjust scroll properly
            if [ "$filename" = ".." ]; then
                # Get the now-selected item (directory we just left)
                local selected_info
                IFS='|' read -r selected_filename selected_type selected_path <<< "$($list.get_selected_item)"
                
                # Adjust scroll using panel's actual height
                local height=$(__PANEL__.height)
                local visible_rows=$((height - 3))
                $list.find_and_select "$selected_filename" $visible_rows
            fi
            
            __PANEL__.prerender_all_rows
            __PANEL__.render
            __PANEL__.enter_result = "ok"
        elif [ "$filetype" = "f" ]; then
            # TODO: Extract file from archive for viewing
            __PANEL__.enter_result = "archive_file:$filename"
        fi
        return
    fi
    
    # Normal filesystem mode
    if [ "$filetype" = "d" ] && [ "$filename" != "<empty>" ]; then
        if [ "$filename" = ".." ]; then
            # Going up - remember current directory name
            local current_dir="${path##*/}"  # basename
            local parent_dir="${path%/*}"    # dirname
            
            # Handle root directory edge case
            if [ -z "$parent_dir" ]; then
                parent_dir="/"
            fi
            
            $list.path = "$parent_dir"
            cd "$parent_dir" 2>/dev/null || true
            
            # Find and select the directory we just left
            local height=$(__PANEL__.height)
            local visible_rows=$((height - 3))
            $list.find_and_select "$current_dir" $visible_rows
            
            # Pre-render all rows AFTER cursor is positioned
            __PANEL__.prerender_all_rows
        else
            # Going into subdirectory
            local new_path
            if [ "$path" = "/" ]; then
                new_path="/$filename"
            else
                new_path="$path/$filename"
            fi
            $list.path = "$new_path"
            cd "$new_path" 2>/dev/null || true
            
            # Pre-render all rows with new directory
            __PANEL__.prerender_all_rows
        fi
        
        # Render panel with new directory
        __PANEL__.render
        __PANEL__.enter_result = "ok"
    elif [ "$filetype" = "f" ] && [ "$filename" != "<empty>" ]; then
        # Check if it's an archive file
        if __PANEL__._is_archive "$filename"; then
            __PANEL__._enter_archive "$filename"
            __PANEL__.render
            __PANEL__.enter_result = "ok"
        else
            # Regular file - check if executable
            local filepath="$path/$filename"
            
            if [ -x "$filepath" ]; then
                __PANEL__.enter_result = "execute:$filepath"
            else
                __PANEL__.enter_result = "open:$filepath"
            fi
        fi
    else
        # Special item or empty
        __PANEL__.enter_result = ""
    fi
}

