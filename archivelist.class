#!/bin/bash
# archivelist.class - Archive browsing using ba.sh

__ARCHIVELIST___properties=()

__ARCHIVELIST__.property(){
    # Property indices
    local archive_path=0
    local archive_type=1
    local internal_path=2
    local selected=3
    local scroll=4
    
    if [ "$2" = "=" ]; then
        __ARCHIVELIST___properties[$1]="$3"
    else
        echo "${__ARCHIVELIST___properties[$1]}"
    fi
}

# Property accessors
__ARCHIVELIST__.archive_path(){
    if [ "$1" = "=" ]; then
        __ARCHIVELIST__.property archive_path = "$2"
        # Auto-detect archive_type from filename extension
        local _fname="${2##*/}"
        local _detected
        case "${_fname,,}" in
            *.tar.gz|*.tgz)   _detected="tar.gz" ;;
            *.tar.bz2|*.tbz2) _detected="tar.bz2" ;;
            *.tar.xz|*.txz)   _detected="tar.xz" ;;
            *.tar)            _detected="tar" ;;
            *.zip)            _detected="zip" ;;
            *.rar)            _detected="rar" ;;
            *.7z)             _detected="7z" ;;
            *.deb)            _detected="deb" ;;
            *.rpm)            _detected="rpm" ;;
            *.iso)            _detected="iso" ;;
        esac
        __ARCHIVELIST__.property archive_type = "$_detected"
    else
        __ARCHIVELIST__.property archive_path
    fi
}

__ARCHIVELIST__.archive_type(){
    if [ "$1" = "=" ]; then
        __ARCHIVELIST__.property archive_type = "$2"
    else
        __ARCHIVELIST__.property archive_type
    fi
}

__ARCHIVELIST__.internal_path(){
    if [ "$1" = "=" ]; then
        __ARCHIVELIST__.property internal_path = "$2"
    else
        __ARCHIVELIST__.property internal_path
    fi
}

__ARCHIVELIST__.selected(){
    if [ "$1" = "=" ]; then
        __ARCHIVELIST__.property selected = "$2"
    else
        __ARCHIVELIST__.property selected
    fi
}

__ARCHIVELIST__.scroll(){
    if [ "$1" = "=" ]; then
        __ARCHIVELIST__.property scroll = "$2"
    else
        __ARCHIVELIST__.property scroll
    fi
}

__ARCHIVELIST__.path(){
    # Return display path: /path/to/archive.tar.gz//internal/path
    local archive=$(__ARCHIVELIST__.archive_path)
    local internal=$(__ARCHIVELIST__.internal_path)
    
    if [ -z "$internal" ]; then
        echo "$archive//"
    else
        echo "$archive//$internal"
    fi
}

# Arrays for archive entries
# Full archive list loaded once
declare -ag __ARCHIVELIST___all_entries=()  # Format: "fullpath|size"

# Filtered display arrays (same as filelist)
declare -ag __ARCHIVELIST___files=()
declare -ag __ARCHIVELIST___types=()
declare -ag __ARCHIVELIST___sizes=()
declare -ag __ARCHIVELIST___times=()
declare -ag __ARCHIVELIST___full_paths=()
declare -ag __ARCHIVELIST___marked=()   # 1 = marked for operation, 0 = not marked

# Format a byte count the same way filelist does
# Detect ISO extension flag for isoinfo
# Returns -R if Rock Ridge is present, "" otherwise
# Joliet is intentionally ignored - isoinfo extraction via -J is unreliable
__ARCHIVELIST__._iso_ext_flag(){
    local archive_path="$1"
    if isoinfo -d -i "$archive_path" 2>/dev/null | grep -q "Rock Ridge signatures"; then
        echo "-R"
    else
        echo ""
    fi
}

__ARCHIVELIST__._format_size(){
    local size="$1"
    if [[ ! "$size" =~ ^[0-9]+$ ]]; then
        echo ""
    elif [ "$size" -lt 1000000 ]; then
        echo "$size"
    elif [ "$size" -lt 1000000000 ]; then
        echo "$((size / 1024))K"
    else
        echo "$((size / 1048576))M"
    fi
}

# Detect archive type from filename
# Load full archive contents once (called on first load only)
__ARCHIVELIST__._load_full_archive(){
    local archive_path=$(__ARCHIVELIST__.archive_path)
    local archive_type=$(__ARCHIVELIST__.archive_type)
    
    
    __ARCHIVELIST___all_entries=()
    
    case "$archive_type" in
        tar|tar.gz|tar.bz2|tar.xz)
            while IFS= read -r line; do
                local size=$(echo "$line" | awk '{print $3}')
                local filename=$(echo "$line" | awk '{$1=$2=$3=$4=$5=""; sub(/^[ \t]+/, ""); print}')
                local size_str=$(__ARCHIVELIST__._format_size "$size")
                __ARCHIVELIST___all_entries+=("$filename|$size_str")
            done < <(tar -tvf "$archive_path" 2>/dev/null)
            ;;
        zip)
            # ZIP files may have extra info/text before the file list
            # Look for separator line (dashes) to find the start of file listing
            local in_listing=0
            while IFS= read -r line; do
                # Find separator line with dashes
                if [[ "$line" =~ ^-{5,} ]]; then
                    if [ $in_listing -eq 0 ]; then
                        # First separator - file listing starts after this
                        in_listing=1
                        continue
                    else
                        # Second separator - end of listing
                        break
                    fi
                fi
                
                # Skip until we're in the listing
                [ $in_listing -eq 0 ] && continue
                
                # Skip lines with less than 4 fields
                local field_count=$(echo "$line" | awk '{print NF}')
                [ "$field_count" -lt 4 ] && continue
                
                local size=$(echo "$line" | awk '{print $1}')
                local filename=$(echo "$line" | awk '{$1=$2=$3=""; sub(/^[ \t]+/, ""); print}')
                
                # Skip if size is not numeric
                [[ ! "$size" =~ ^[0-9]+$ ]] && continue
                
                local size_str=$(__ARCHIVELIST__._format_size "$size")
                [ -n "$filename" ] && __ARCHIVELIST___all_entries+=("$filename|$size_str")
            done < <(unzip -l "$archive_path" 2>/dev/null)
            ;;
        rar)
            # unrar l output: attr size date time name
            # Unix attrs: first char 'd' = directory
            # DOS attrs:  'D' anywhere in attr field = directory
            while IFS= read -r line; do
                local _attr _size _date _time _name
                read -r _attr _size _date _time _name <<< "$line"
                # Must have a valid numeric size and a name
                [[ "$_size" =~ ^[0-9]+$ ]] || continue
                [ -z "$_name" ] && continue
                # Skip directories
                [[ "$_attr" == d* ]] && continue
                [[ "$_attr" == *D* ]] && continue
                local size_str=$(__ARCHIVELIST__._format_size "$_size")
                __ARCHIVELIST___all_entries+=("$_name|$size_str")
            done < <(unrar l "$archive_path" 2>/dev/null)
            ;;
        7z)
            local cmd=""
            if command -v 7z >/dev/null 2>&1; then
                cmd="7z"
            elif command -v 7za >/dev/null 2>&1; then
                cmd="7za"
            elif command -v 7zr >/dev/null 2>&1; then
                cmd="7zr"
            fi
            
            
            if [ -n "$cmd" ]; then
                local separator_line=""
                local filename_pos=0
                local in_listing=0
                local line_count=0
                
                while IFS= read -r line; do
                    line_count=$(( line_count + 1 ))
                    
                    # Find separator line with dashes
                    if [[ "$line" =~ ^-{10,} ]]; then
                        if [ $in_listing -eq 0 ]; then
                            # First separator - save it to find filename position
                            separator_line="$line"
                            # Find where last dash section starts
                            local temp="${separator_line% -*}"
                            filename_pos=${#temp}
                            filename_pos=$(( filename_pos + 1 ))
                            in_listing=1
                            continue
                        else
                            # Second separator - end of listing
                            break
                        fi
                    fi
                    
                    # Skip until we're in the listing
                    if [ $in_listing -eq 0 ]; then
                        continue
                    fi
                    
                    # Skip empty lines (can appear between separator and files)
                    if [[ -z "$line" ]]; then
                        continue
                    fi
                    
                    # Extract filename by position
                    local filename="${line:$filename_pos}"
                    
                    # Extract size (column 4) and attributes (column 3)
                    local attr=$(echo "$line" | awk '{print $3}')
                    local size=$(echo "$line" | awk '{print $4}')
                    
                    
                    [[ -z "$filename" ]] && continue
                    
                    # Check if it's a directory (D in attribute column)
                    local is_dir=0
                    if [[ "$attr" == D* ]]; then
                        is_dir=1
                    fi
                    
                    # For directories, append / to the filename
                    if [ $is_dir -eq 1 ]; then
                        filename="${filename}/"
                    fi
                    
                    local size_str=$(__ARCHIVELIST__._format_size "$size")
                    __ARCHIVELIST___all_entries+=("$filename|$size_str")
                    
                done < <($cmd l "$archive_path" 2>/dev/null)
                
            fi
            ;;
        deb)
            # List control scripts under DEBIAN/ prefix
            while IFS= read -r line; do
                local size=$(echo "$line" | awk '{print $3}')
                local filename=$(echo "$line" | awk '{print $6}')
                filename="${filename#./}"
                { [ -z "$filename" ] || [ "$filename" = "." ]; } && continue
                local size_str=$(__ARCHIVELIST__._format_size "$size")
                __ARCHIVELIST___all_entries+=("DEBIAN/$filename|$size_str")
            done < <(dpkg-deb --ctrl-tarfile "$archive_path" 2>/dev/null | tar -tv 2>/dev/null)
            # List data files
            while IFS= read -r line; do
                local size=$(echo "$line" | awk '{print $3}')
                local filename=$(echo "$line" | awk '{print $6}')
                filename="${filename#./}"
                { [ -z "$filename" ] || [ "$filename" = "." ]; } && continue
                local size_str=$(__ARCHIVELIST__._format_size "$size")
                __ARCHIVELIST___all_entries+=("$filename|$size_str")
            done < <(dpkg-deb --fsys-tarfile "$archive_path" 2>/dev/null | tar -tv 2>/dev/null)
            ;;
        rpm)
            # rpm -qlp lists files; rpm -qp --queryformat gives sizes
            if command -v rpm &>/dev/null; then
                while IFS= read -r line; do
                    local size="${line%% *}"
                    local filename="${line#* }"
                    # Strip leading /
                    filename="${filename#/}"
                    [ -z "$filename" ] && continue
                    local size_str=$(__ARCHIVELIST__._format_size "$size")
                    __ARCHIVELIST___all_entries+=("$filename|$size_str")
                done < <(rpm -qp --queryformat '[%{FILESIZES} %{FILENAMES}\n]' "$archive_path" 2>/dev/null)
            fi
            ;;
        iso)
            # Requires isoinfo from genisoimage package.
            # Try Rock Ridge (-R) first for correct case, then Joliet (-J),
            # then plain ISO 9660 as fallback.
            if command -v isoinfo &>/dev/null; then
                # Detect which extensions are available via isoinfo -d
                local _ext_flag
                _ext_flag=$(__ARCHIVELIST__._iso_ext_flag "$archive_path")

                # Build size map from -l output
                # Format: perms links uid gid size month day year [ lba ] name
                declare -A _iso_sizes=()
                local _cur_dir=""
                while IFS= read -r line; do
                    if [[ "$line" =~ ^"Directory listing of "(.*) ]]; then
                        _cur_dir="${BASH_REMATCH[1]%/}"
                        continue
                    fi
                    [[ -z "$line" || "$line" =~ ^d ]] && continue
                    local _size _name
                    read -r _ _ _ _ _size _ _ _ _ _ _ _name <<< "$line"
                    [[ "$_size" =~ ^[0-9]+$ ]] || continue
                    [ -z "$_name" ] && continue
                    _iso_sizes["${_cur_dir}/${_name}"]="$_size"
                done < <(isoinfo $_ext_flag -l -i "$archive_path" 2>/dev/null)

                # Build set of known directories from -l output (lines starting with d)
                declare -A _iso_dirs=()
                while IFS= read -r line; do
                    if [[ "$line" =~ ^"Directory listing of "(.*) ]]; then
                        local _dpath="${BASH_REMATCH[1]%/}"
                        [ -n "$_dpath" ] && _iso_dirs["${_dpath#/}"]="1"
                        continue
                    fi
                done < <(isoinfo $_ext_flag -l -i "$archive_path" 2>/dev/null)

                # List all files - skip directory entries
                while IFS= read -r filepath; do
                    [ -z "$filepath" ] && continue
                    # Without extensions, files have ;1 suffix - skip dirs (no ;1)
                    if [ -z "$_ext_flag" ]; then
                        [[ "$filepath" != *";"* ]] && continue
                    fi
                    # Strip version suffix and leading /
                    local clean="${filepath%;*}"
                    clean="${clean#/}"
                    [ -z "$clean" ] && continue
                    # Skip if this path is a known directory
                    [ "${_iso_dirs[$clean]}" = "1" ] && continue
                    local size="${_iso_sizes[$filepath]:-0}"
                    local size_str=$(__ARCHIVELIST__._format_size "$size")
                    __ARCHIVELIST___all_entries+=("$clean|$size_str")
                done < <(isoinfo $_ext_flag -f -i "$archive_path" 2>/dev/null)
            fi
            ;;
    esac
}

# Filter all_entries by internal_path
__ARCHIVELIST__._filter_by_path(){
    local internal_path=$(__ARCHIVELIST__.internal_path)
    local current_prefix="$internal_path"
    [ -n "$current_prefix" ] && current_prefix="${current_prefix}/"
    
    local -a subdirs=()
    local -a files=()
    
    for entry in "${__ARCHIVELIST___all_entries[@]}"; do
        IFS='|' read -r entry_name entry_size <<< "$entry"
        
        [[ "$entry_name" != "$current_prefix"* ]] && continue
        
        local relative="${entry_name#$current_prefix}"
        [ -z "$relative" ] && continue
        
        if [[ "$relative" == */* ]]; then
            local subdir="${relative%%/*}"
            
            local already_added=0
            for d in "${subdirs[@]}"; do
                if [ "$d" = "$subdir" ]; then
                    already_added=1
                    break
                fi
            done
            
            [ $already_added -eq 0 ] && subdirs+=("$subdir")
        else
            files+=("$relative|$entry_name|$entry_size")
        fi
    done
    
    # Add subdirectories
    for dir in "${subdirs[@]}"; do
        __ARCHIVELIST___files+=("$dir")
        __ARCHIVELIST___types+=("d")
        __ARCHIVELIST___sizes+=("SUB-DIR")
        __ARCHIVELIST___times+=("")
        __ARCHIVELIST___full_paths+=("${current_prefix}${dir}")
        __ARCHIVELIST___marked+=("0")
    done
    
    # Add files
    for file_entry in "${files[@]}"; do
        IFS='|' read -r filename fullpath filesize <<< "$file_entry"
        __ARCHIVELIST___files+=("$filename")
        __ARCHIVELIST___types+=("f")
        __ARCHIVELIST___sizes+=("$filesize")
        __ARCHIVELIST___times+=("")
        __ARCHIVELIST___full_paths+=("$fullpath")
        __ARCHIVELIST___marked+=("0")
    done
}

# Load (or filter) archive contents at current internal path
__ARCHIVELIST__.load(){
    
    # Clear display arrays
    __ARCHIVELIST___files=()
    __ARCHIVELIST___types=()
    __ARCHIVELIST___sizes=()
    __ARCHIVELIST___times=()
    __ARCHIVELIST___full_paths=()
    __ARCHIVELIST___marked=()
    __ARCHIVELIST__.selected = 0
    __ARCHIVELIST__.scroll = 0
    
    # Load full archive if not already loaded
    if [ ${#__ARCHIVELIST___all_entries[@]} -eq 0 ]; then
        __ARCHIVELIST__._load_full_archive
    fi
    
    # Always add ".."
    __ARCHIVELIST___files+=("..")
    __ARCHIVELIST___types+=("d")
    __ARCHIVELIST___sizes+=("UP--DIR")
    __ARCHIVELIST___times+=("")
    __ARCHIVELIST___full_paths+=("")
    __ARCHIVELIST___marked+=("0")
    
    # Filter for current path
    __ARCHIVELIST__._filter_by_path
}

# Get entry at index (same format as filelist)
__ARCHIVELIST__.get(){
    local index="$1"
    echo "${__ARCHIVELIST___files[$index]}|${__ARCHIVELIST___types[$index]}|${__ARCHIVELIST___sizes[$index]}|${__ARCHIVELIST___times[$index]}|0|${__ARCHIVELIST___marked[$index]:-0}|"
}

# Get count
__ARCHIVELIST__.count(){
    echo ${#__ARCHIVELIST___files[@]}
}

# Navigate (UP/DOWN/etc)
__ARCHIVELIST__.navigate(){
    local direction="$1"
    local max_visible="${2:-20}"
    
    local selected=$(__ARCHIVELIST__.selected)
    local count=${#__ARCHIVELIST___files[@]}
    
    case "$direction" in
        UP)
            if [ $selected -gt 0 ]; then
                local new_selected=$((selected - 1))
                __ARCHIVELIST__.selected = $new_selected
                
                local scroll=$(__ARCHIVELIST__.scroll)
                if [ $new_selected -lt $scroll ]; then
                    __ARCHIVELIST__.scroll = $new_selected
                fi
            fi
            ;;
        DOWN)
            if [ $selected -lt $((count - 1)) ]; then
                local new_selected=$((selected + 1))
                __ARCHIVELIST__.selected = $new_selected
                
                local scroll=$(__ARCHIVELIST__.scroll)
                if [ $new_selected -ge $((scroll + max_visible)) ]; then
                    __ARCHIVELIST__.scroll = $((scroll + 1))
                fi
            fi
            ;;
        PAGEUP)
            local new_selected=$((selected - max_visible))
            [ $new_selected -lt 0 ] && new_selected=0
            __ARCHIVELIST__.selected = $new_selected
            
            local scroll=$(__ARCHIVELIST__.scroll)
            if [ $new_selected -lt $scroll ]; then
                __ARCHIVELIST__.scroll = $new_selected
            fi
            ;;
        PAGEDOWN)
            local new_selected=$((selected + max_visible))
            [ $new_selected -ge $count ] && new_selected=$((count - 1))
            __ARCHIVELIST__.selected = $new_selected
            
            local scroll=$(__ARCHIVELIST__.scroll)
            if [ $new_selected -ge $((scroll + max_visible)) ]; then
                __ARCHIVELIST__.scroll = $((new_selected - max_visible + 1))
            fi
            ;;
        HOME)
            __ARCHIVELIST__.selected = 0
            __ARCHIVELIST__.scroll = 0
            ;;
        END)
            __ARCHIVELIST__.selected = $((count - 1))
            local scroll=$((count - max_visible))
            [ $scroll -lt 0 ] && scroll=0
            __ARCHIVELIST__.scroll = $scroll
            ;;
    esac
}

# Extract files to destination directory
# $1 = destination directory
# $2... = internal paths to extract (empty = extract all)
__ARCHIVELIST__.extract_files(){
    local dest="$1"
    shift
    local files=("$@")

    local archive_path=$(__ARCHIVELIST__.archive_path)
    local archive_type=$(__ARCHIVELIST__.archive_type)


    mkdir -p "$dest" 2>/dev/null || return 1

    if [ ${#files[@]} -eq 0 ]; then
        # Extract everything
        case "$archive_type" in
            tar|tar.gz|tar.bz2|tar.xz)
                tar -xf "$archive_path" -C "$dest" >/dev/null 2>&1 ;;
            zip)
                unzip -q "$archive_path" -d "$dest" >/dev/null 2>&1 ;;
            rar)
                unrar x -y "$archive_path" "$dest/" >/dev/null 2>&1 ;;
            7z)
                local cmd=""
                command -v 7z &>/dev/null && cmd="7z"
                command -v 7za &>/dev/null && [ -z "$cmd" ] && cmd="7za"
                command -v 7zr &>/dev/null && [ -z "$cmd" ] && cmd="7zr"
                [ -n "$cmd" ] && $cmd x "$archive_path" -o"$dest" -y 2>/dev/null ;;
            deb)
                mkdir -p "$dest/DEBIAN"
                dpkg-deb --ctrl-tarfile "$archive_path" >/dev/null 2>&1 | \
                    tar -xf - -C "$dest/DEBIAN" >/dev/null 2>&1
                dpkg-deb -x "$archive_path" "$dest" >/dev/null 2>&1 ;;
            rpm)
                if command -v rpm2cpio &>/dev/null && command -v cpio &>/dev/null; then
                    ( cd "$dest" && rpm2cpio "$archive_path" | cpio -idm --quiet >/dev/null 2>&1 )
                fi ;;
            iso)
                # Extract all files preserving directory structure
                if command -v isoinfo &>/dev/null; then
                    local _ext
                    _ext=$(__ARCHIVELIST__._iso_ext_flag "$archive_path")
                    while IFS= read -r fp; do
                        [ -z "$fp" ] && continue
                        local clean out_path
                        if [ -n "$_ext" ]; then
                            # Rock Ridge: paths are long/lowercase, no ;1
                            clean="${fp#/}"
                            out_path="$dest/$clean"
                            mkdir -p "$(dirname "$out_path")" 2>/dev/null
                            isoinfo -R -i "$archive_path" -x "/$clean" >"$out_path" 2>/dev/null || true
                        else
                            # Plain/Joliet: paths have ;1, skip dirs (no ;1)
                            [[ "$fp" != *";"* ]] && continue
                            clean="${fp%;*}"
                            out_path="$dest/${clean#/}"
                            mkdir -p "$(dirname "$out_path")" 2>/dev/null
                            isoinfo -i "$archive_path" -x "$fp" >"$out_path" 2>/dev/null || true
                        fi
                    done < <(isoinfo $_ext -f -i "$archive_path" 2>/dev/null)
                fi ;;
        esac
    else
        # Extract specific files
        case "$archive_type" in
            tar|tar.gz|tar.bz2|tar.xz)
                local tmp=$(mktemp -d)
                tar -xf "$archive_path" -C "$tmp" "${files[@]}" >/dev/null 2>&1
                for f in "${files[@]}"; do
                    local src="$tmp/${f#/}"
                    [ -e "$src" ] && cp -r "$src" "$dest/" 2>/dev/null
                done
                rm -rf "$tmp" ;;
            zip)
                local tmp=$(mktemp -d)
                unzip -q "$archive_path" "${files[@]}" -d "$tmp" >/dev/null 2>&1
                for f in "${files[@]}"; do
                    local src="$tmp/${f#/}"
                    [ -e "$src" ] && cp -r "$src" "$dest/" 2>/dev/null
                done
                rm -rf "$tmp" ;;
            rar)
                local tmp=$(mktemp -d)
                for f in "${files[@]}"; do
                    unrar x -y "$archive_path" "$f" "$tmp/" >/dev/null 2>&1
                    local src="$tmp/${f#/}"
                    [ -e "$src" ] && cp -r "$src" "$dest/" 2>/dev/null
                done
                rm -rf "$tmp" ;;
            7z)
                local cmd=""
                command -v 7z &>/dev/null && cmd="7z"
                command -v 7za &>/dev/null && [ -z "$cmd" ] && cmd="7za"
                command -v 7zr &>/dev/null && [ -z "$cmd" ] && cmd="7zr"
                if [ -n "$cmd" ]; then
                    local tmp=$(mktemp -d)
                    for f in "${files[@]}"; do
                        $cmd x "$archive_path" -o"$tmp" -y "$f" >/dev/null 2>&1 || true
                        local src="$tmp/${f#/}"
                        [ -e "$src" ] && cp -r "$src" "$dest/" 2>/dev/null
                    done
                    rm -rf "$tmp"
                fi ;;
            deb)
                local tmp=$(mktemp -d)
                for f in "${files[@]}"; do
                    if [[ "$f" == DEBIAN/* ]]; then
                        # Control file - extract from ctrl-tarfile
                        local ctrl_name="${f#DEBIAN/}"
                        dpkg-deb --ctrl-tarfile "$archive_path" >/dev/null 2>&1 | \
                            tar -xf - -C "$tmp" "./$ctrl_name" >/dev/null 2>&1
                        local src="$tmp/$ctrl_name"
                    else
                        # Data file - extract from fsys-tarfile
                        dpkg-deb --fsys-tarfile "$archive_path" >/dev/null 2>&1 | \
                            tar -xf - -C "$tmp" "./$f" >/dev/null 2>&1
                        local src="$tmp/$f"
                    fi
                    [ -e "$src" ] && cp -r "$src" "$dest/" 2>/dev/null
                done
                rm -rf "$tmp" ;;
            rpm)
                if command -v rpm2cpio &>/dev/null && command -v cpio &>/dev/null; then
                    local tmp=$(mktemp -d)
                    ( cd "$tmp" && rpm2cpio "$archive_path" | cpio -idm --quiet >/dev/null 2>&1 )
                    for f in "${files[@]}"; do
                        local src="$tmp/${f#/}"
                        [ -e "$src" ] && cp -r "$src" "$dest/" 2>/dev/null
                    done
                    rm -rf "$tmp"
                fi ;;
            iso)
                # Extract specific files flat into dest (ignore internal path)
                # Extract specific files flat into dest (ignore internal path)
                if command -v isoinfo &>/dev/null; then
                    local _ext
                    _ext=$(__ARCHIVELIST__._iso_ext_flag "$archive_path")
                    for f in "${files[@]}"; do
                        local basename="${f##*/}"
                        local out_path="$dest/$basename"
                        if [ -n "$_ext" ]; then
                            # Rock Ridge: stored paths are long/lowercase, use -R -x directly
                            isoinfo -R -i "$archive_path" -x "/$f" >"$out_path" 2>/dev/null || true
                        else
                            # Plain/Joliet: stored paths are uppercase without ;1, add it back
                            isoinfo -i "$archive_path" -x "/${f^^};1" >"$out_path" 2>/dev/null || true
                        fi
                    done
                fi ;;
        esac
    fi
}

# Cleanup - clear all arrays to free memory
__ARCHIVELIST__.cleanup(){
    __ARCHIVELIST___all_entries=()
    __ARCHIVELIST___files=()
    __ARCHIVELIST___types=()
    __ARCHIVELIST___sizes=()
    __ARCHIVELIST___times=()
    __ARCHIVELIST___full_paths=()
    __ARCHIVELIST__.selected = 0
    __ARCHIVELIST__.scroll = 0
}

# Check if special entry
__ARCHIVELIST__.is_special(){
    local filename="$1"
    [[ "$filename" == ".." || "$filename" == "<empty>" ]]
}

# Enter directory
__ARCHIVELIST__.enter(){
    local selected=$(__ARCHIVELIST__.selected)
    local filename="${__ARCHIVELIST___files[$selected]}"
    local filetype="${__ARCHIVELIST___types[$selected]}"
    
    if [ "$filename" = ".." ]; then
        # Go up one level
        local internal=$(__ARCHIVELIST__.internal_path)
        
        local leaving_dir="${internal##*/}"
        local parent="${internal%/*}"
        
        if [ "$parent" = "$internal" ]; then
            parent=""
        fi
        
        __ARCHIVELIST__.internal_path = "$parent"
        __ARCHIVELIST__.load
        
        # Find and select the directory we just left (with scroll adjustment)
        if [ -n "$leaving_dir" ]; then
            # Get max_visible from panel height (estimate 20 if unknown)
            __ARCHIVELIST__.find_and_select "$leaving_dir" 20
        fi
    elif [ "$filetype" = "d" ]; then
        # Enter subdirectory
        local internal=$(__ARCHIVELIST__.internal_path)
        
        if [ -z "$internal" ]; then
            __ARCHIVELIST__.internal_path = "$filename"
        else
            __ARCHIVELIST__.internal_path = "$internal/$filename"
        fi
        
        __ARCHIVELIST__.load
    fi
}

# Get selected item info
__ARCHIVELIST__.get_selected_item(){
    local selected=$(__ARCHIVELIST__.selected)
    local filename="${__ARCHIVELIST___files[$selected]}"
    local filetype="${__ARCHIVELIST___types[$selected]}"
    local path="${__ARCHIVELIST___full_paths[$selected]}"
    
    echo "$filename|$filetype|$path"
}

# Stub methods for filelist API compatibility
__ARCHIVELIST__.toggle_selection(){
    local selected=$(__ARCHIVELIST__.selected)
    local filename="${__ARCHIVELIST___files[$selected]}"
    # Don't allow selecting .. 
    [[ "$filename" == ".." ]] && return
    if [ "${__ARCHIVELIST___marked[$selected]:-0}" = "1" ]; then
        __ARCHIVELIST___marked[$selected]="0"
    else
        __ARCHIVELIST___marked[$selected]="1"
    fi
}

__ARCHIVELIST__.count_selected(){
    local count=0
    for mark in "${__ARCHIVELIST___marked[@]}"; do
        [ "$mark" = "1" ] && count=$((count + 1))
    done
    echo $count
}

__ARCHIVELIST__.marked_count(){ __ARCHIVELIST__.count_selected; }

__ARCHIVELIST__.marked_size(){
    local total=0
    local n=${#__ARCHIVELIST___marked[@]}
    for ((i=0; i<n; i++)); do
        if [ "${__ARCHIVELIST___marked[$i]}" = "1" ] && [ "${__ARCHIVELIST___types[$i]}" = "f" ]; then
            local s="${__ARCHIVELIST___sizes[$i]}"
            if [[ "$s" =~ ^[0-9]+$ ]]; then
                total=$((total + s))
            elif [[ "$s" =~ ^([0-9]+)K$ ]]; then
                total=$((total + ${BASH_REMATCH[1]} * 1024))
            elif [[ "$s" =~ ^([0-9]+)M$ ]]; then
                total=$((total + ${BASH_REMATCH[1]} * 1048576))
            fi
        fi
    done
    echo $total
}

# Returns newline-separated internal paths of all marked entries
__ARCHIVELIST__.get_marked_paths(){
    local n=${#__ARCHIVELIST___marked[@]}
    for ((i=0; i<n; i++)); do
        if [ "${__ARCHIVELIST___marked[$i]}" = "1" ]; then
            echo "${__ARCHIVELIST___full_paths[$i]}"
        fi
    done
}
__ARCHIVELIST__.selection_info(){ echo "0|0"; }
__ARCHIVELIST__.find_and_select(){
    local target_name="$1"
    local max_visible="${2:-20}"
    
    local count=${#__ARCHIVELIST___files[@]}
    
    # Search for the item
    for ((i=0; i<count; i++)); do
        if [ "${__ARCHIVELIST___files[$i]}" = "$target_name" ]; then
            # Found it - select and adjust scroll
            __ARCHIVELIST__.selected = $i
            
            # Adjust scroll to make it visible
            local scroll=$(__ARCHIVELIST__.scroll)
            if [ $i -lt $scroll ]; then
                scroll=$i
            elif [ $i -ge $((scroll + max_visible)) ]; then
                scroll=$((i - max_visible + 1))
            fi
            
            # Clamp scroll to prevent empty rows at bottom
            local max_scroll=$((count - max_visible))
            if [ $max_scroll -lt 0 ]; then
                max_scroll=0
            fi
            if [ $scroll -gt $max_scroll ]; then
                scroll=$max_scroll
            fi
            
            __ARCHIVELIST__.scroll = $scroll
            return 0
        fi
    done
    
    # Not found - leave selection as is
    return 1
}
__ARCHIVELIST__.sort_order(){ echo "name_asc"; }

__ARCHIVELIST__.type(){ echo "archive"; }
__ARCHIVELIST__.get_selected(){ __ARCHIVELIST__.get_selected_item; }

