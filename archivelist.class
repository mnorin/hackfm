#!/bin/bash
# archivelist.class - Archive browsing using ba.sh

__ARCHIVELIST___properties=()

__ARCHIVELIST__.property(){
    # Property indices
    local archive_path=0
    local archive_type=1
    local internal_path=2
    local selected=3
    local scroll=4
    
    if [ "$2" = "=" ]; then
        __ARCHIVELIST___properties[$1]="$3"
    else
        echo "${__ARCHIVELIST___properties[$1]}"
    fi
}

# Property accessors
__ARCHIVELIST__.archive_path(){
    if [ "$1" = "=" ]; then
        __ARCHIVELIST__.property archive_path = "$2"
        # Auto-detect archive_type from filename extension
        local _fname="${2##*/}"
        local _detected
        case "${_fname,,}" in
            *.tar.gz|*.tgz)   _detected="tar.gz" ;;
            *.tar.bz2|*.tbz2) _detected="tar.bz2" ;;
            *.tar.xz|*.txz)   _detected="tar.xz" ;;
            *.tar)            _detected="tar" ;;
            *.zip)            _detected="zip" ;;
            *.rar)            _detected="rar" ;;
            *.7z)             _detected="7z" ;;
            *.deb)            _detected="deb" ;;
            *.rpm)            _detected="rpm" ;;
        esac
        __ARCHIVELIST__.property archive_type = "$_detected"
    else
        __ARCHIVELIST__.property archive_path
    fi
}

__ARCHIVELIST__.archive_type(){
    if [ "$1" = "=" ]; then
        __ARCHIVELIST__.property archive_type = "$2"
    else
        __ARCHIVELIST__.property archive_type
    fi
}

__ARCHIVELIST__.internal_path(){
    if [ "$1" = "=" ]; then
        __ARCHIVELIST__.property internal_path = "$2"
    else
        __ARCHIVELIST__.property internal_path
    fi
}

__ARCHIVELIST__.selected(){
    if [ "$1" = "=" ]; then
        __ARCHIVELIST__.property selected = "$2"
    else
        __ARCHIVELIST__.property selected
    fi
}

__ARCHIVELIST__.scroll(){
    if [ "$1" = "=" ]; then
        __ARCHIVELIST__.property scroll = "$2"
    else
        __ARCHIVELIST__.property scroll
    fi
}

__ARCHIVELIST__.path(){
    # Return display path: /path/to/archive.tar.gz//internal/path
    local archive=$(__ARCHIVELIST__.archive_path)
    local internal=$(__ARCHIVELIST__.internal_path)
    
    if [ -z "$internal" ]; then
        echo "$archive//"
    else
        echo "$archive//$internal"
    fi
}

# Arrays for archive entries
# Full archive list loaded once
declare -ag __ARCHIVELIST___all_entries=()  # Format: "fullpath|size"

# Filtered display arrays (same as filelist)
declare -ag __ARCHIVELIST___files=()
declare -ag __ARCHIVELIST___types=()
declare -ag __ARCHIVELIST___sizes=()
declare -ag __ARCHIVELIST___times=()
declare -ag __ARCHIVELIST___full_paths=()

# Format a byte count the same way filelist does
__ARCHIVELIST__._format_size(){
    local size="$1"
    if [[ ! "$size" =~ ^[0-9]+$ ]]; then
        echo ""
    elif [ "$size" -lt 1000000 ]; then
        echo "$size"
    elif [ "$size" -lt 1000000000 ]; then
        echo "$((size / 1024))K"
    else
        echo "$((size / 1048576))M"
    fi
}

# Detect archive type from filename
# Load full archive contents once (called on first load only)
__ARCHIVELIST__._load_full_archive(){
    local archive_path=$(__ARCHIVELIST__.archive_path)
    local archive_type=$(__ARCHIVELIST__.archive_type)
    
    
    __ARCHIVELIST___all_entries=()
    
    case "$archive_type" in
        tar|tar.gz|tar.bz2|tar.xz)
            while IFS= read -r line; do
                local size=$(echo "$line" | awk '{print $3}')
                local filename=$(echo "$line" | awk '{$1=$2=$3=$4=$5=""; sub(/^[ \t]+/, ""); print}')
                local size_str=$(__ARCHIVELIST__._format_size "$size")
                __ARCHIVELIST___all_entries+=("$filename|$size_str")
            done < <(tar -tvf "$archive_path" 2>/dev/null)
            ;;
        zip)
            # ZIP files may have extra info/text before the file list
            # Look for separator line (dashes) to find the start of file listing
            local in_listing=0
            while IFS= read -r line; do
                # Find separator line with dashes
                if [[ "$line" =~ ^-{5,} ]]; then
                    if [ $in_listing -eq 0 ]; then
                        # First separator - file listing starts after this
                        in_listing=1
                        continue
                    else
                        # Second separator - end of listing
                        break
                    fi
                fi
                
                # Skip until we're in the listing
                [ $in_listing -eq 0 ] && continue
                
                # Skip lines with less than 4 fields
                local field_count=$(echo "$line" | awk '{print NF}')
                [ "$field_count" -lt 4 ] && continue
                
                local size=$(echo "$line" | awk '{print $1}')
                local filename=$(echo "$line" | awk '{$1=$2=$3=""; sub(/^[ \t]+/, ""); print}')
                
                # Skip if size is not numeric
                [[ ! "$size" =~ ^[0-9]+$ ]] && continue
                
                local size_str=$(__ARCHIVELIST__._format_size "$size")
                [ -n "$filename" ] && __ARCHIVELIST___all_entries+=("$filename|$size_str")
            done < <(unzip -l "$archive_path" 2>/dev/null)
            ;;
        rar)
            while IFS= read -r line; do
                __ARCHIVELIST___all_entries+=("$line|")
            done < <(unrar lb "$archive_path" 2>/dev/null)
            ;;
        7z)
            local cmd=""
            if command -v 7z >/dev/null 2>&1; then
                cmd="7z"
            elif command -v 7za >/dev/null 2>&1; then
                cmd="7za"
            elif command -v 7zr >/dev/null 2>&1; then
                cmd="7zr"
            fi
            
            
            if [ -n "$cmd" ]; then
                local separator_line=""
                local filename_pos=0
                local in_listing=0
                local line_count=0
                
                while IFS= read -r line; do
                    ((line_count++))
                    
                    # Find separator line with dashes
                    if [[ "$line" =~ ^-{10,} ]]; then
                        if [ $in_listing -eq 0 ]; then
                            # First separator - save it to find filename position
                            separator_line="$line"
                            # Find where last dash section starts
                            local temp="${separator_line% -*}"
                            filename_pos=${#temp}
                            ((filename_pos++))
                            in_listing=1
                            continue
                        else
                            # Second separator - end of listing
                            break
                        fi
                    fi
                    
                    # Skip until we're in the listing
                    if [ $in_listing -eq 0 ]; then
                        continue
                    fi
                    
                    # Skip empty lines (can appear between separator and files)
                    if [[ -z "$line" ]]; then
                        continue
                    fi
                    
                    # Extract filename by position
                    local filename="${line:$filename_pos}"
                    
                    # Extract size (column 4) and attributes (column 3)
                    local attr=$(echo "$line" | awk '{print $3}')
                    local size=$(echo "$line" | awk '{print $4}')
                    
                    
                    [[ -z "$filename" ]] && continue
                    
                    # Check if it's a directory (D in attribute column)
                    local is_dir=0
                    if [[ "$attr" == D* ]]; then
                        is_dir=1
                    fi
                    
                    # For directories, append / to the filename
                    if [ $is_dir -eq 1 ]; then
                        filename="${filename}/"
                    fi
                    
                    local size_str=$(__ARCHIVELIST__._format_size "$size")
                    __ARCHIVELIST___all_entries+=("$filename|$size_str")
                    
                done < <($cmd l "$archive_path" 2>/dev/null)
                
            fi
            ;;
        deb)
            # dpkg-deb --contents: permissions owner size date time ./path
            while IFS= read -r line; do
                local size=$(echo "$line" | awk '{print $3}')
                local filename=$(echo "$line" | awk '{print $6}')
                # Strip leading ./ from paths
                filename="${filename#./}"
                # Skip root entry
                { [ -z "$filename" ] || [ "$filename" = "." ]; } && continue
                # Trailing / marks directories - keep it for type detection
                local size_str=$(__ARCHIVELIST__._format_size "$size")
                __ARCHIVELIST___all_entries+=("$filename|$size_str")
            done < <(dpkg-deb --contents "$archive_path" 2>/dev/null)
            ;;
        rpm)
            # rpm -qlp lists files; rpm -qp --queryformat gives sizes
            if command -v rpm &>/dev/null; then
                while IFS= read -r line; do
                    local size="${line%% *}"
                    local filename="${line#* }"
                    # Strip leading /
                    filename="${filename#/}"
                    [ -z "$filename" ] && continue
                    local size_str=$(__ARCHIVELIST__._format_size "$size")
                    __ARCHIVELIST___all_entries+=("$filename|$size_str")
                done < <(rpm -qp --queryformat '[%{FILESIZES} %{FILENAMES}\n]' "$archive_path" 2>/dev/null)
            fi
            ;;
    esac
}

# Filter all_entries by internal_path
__ARCHIVELIST__._filter_by_path(){
    local internal_path=$(__ARCHIVELIST__.internal_path)
    local current_prefix="$internal_path"
    [ -n "$current_prefix" ] && current_prefix="${current_prefix}/"
    
    local -a subdirs=()
    local -a files=()
    
    for entry in "${__ARCHIVELIST___all_entries[@]}"; do
        IFS='|' read -r entry_name entry_size <<< "$entry"
        
        [[ "$entry_name" != "$current_prefix"* ]] && continue
        
        local relative="${entry_name#$current_prefix}"
        [ -z "$relative" ] && continue
        
        if [[ "$relative" == */* ]]; then
            local subdir="${relative%%/*}"
            
            local already_added=0
            for d in "${subdirs[@]}"; do
                if [ "$d" = "$subdir" ]; then
                    already_added=1
                    break
                fi
            done
            
            [ $already_added -eq 0 ] && subdirs+=("$subdir")
        else
            files+=("$relative|$entry_name|$entry_size")
        fi
    done
    
    # Add subdirectories
    for dir in "${subdirs[@]}"; do
        __ARCHIVELIST___files+=("$dir")
        __ARCHIVELIST___types+=("d")
        __ARCHIVELIST___sizes+=("SUB-DIR")
        __ARCHIVELIST___times+=("")
        __ARCHIVELIST___full_paths+=("${current_prefix}${dir}")
    done
    
    # Add files
    for file_entry in "${files[@]}"; do
        IFS='|' read -r filename fullpath filesize <<< "$file_entry"
        __ARCHIVELIST___files+=("$filename")
        __ARCHIVELIST___types+=("f")
        __ARCHIVELIST___sizes+=("$filesize")
        __ARCHIVELIST___times+=("")
        __ARCHIVELIST___full_paths+=("$fullpath")
    done
}

# Load (or filter) archive contents at current internal path
__ARCHIVELIST__.load(){
    
    # Clear display arrays
    __ARCHIVELIST___files=()
    __ARCHIVELIST___types=()
    __ARCHIVELIST___sizes=()
    __ARCHIVELIST___times=()
    __ARCHIVELIST___full_paths=()
    __ARCHIVELIST__.selected = 0
    __ARCHIVELIST__.scroll = 0
    
    # Load full archive if not already loaded
    if [ ${#__ARCHIVELIST___all_entries[@]} -eq 0 ]; then
        __ARCHIVELIST__._load_full_archive
    fi
    
    # Always add ".."
    __ARCHIVELIST___files+=("..")
    __ARCHIVELIST___types+=("d")
    __ARCHIVELIST___sizes+=("UP--DIR")
    __ARCHIVELIST___times+=("")
    __ARCHIVELIST___full_paths+=("")
    
    # Filter for current path
    __ARCHIVELIST__._filter_by_path
}

# Get entry at index (same format as filelist)
__ARCHIVELIST__.get(){
    local index="$1"
    echo "${__ARCHIVELIST___files[$index]}|${__ARCHIVELIST___types[$index]}|${__ARCHIVELIST___sizes[$index]}|${__ARCHIVELIST___times[$index]}|0|0|"
}

# Get count
__ARCHIVELIST__.count(){
    echo ${#__ARCHIVELIST___files[@]}
}

# Navigate (UP/DOWN/etc)
__ARCHIVELIST__.navigate(){
    local direction="$1"
    local max_visible="${2:-20}"
    
    local selected=$(__ARCHIVELIST__.selected)
    local count=${#__ARCHIVELIST___files[@]}
    
    case "$direction" in
        UP)
            if [ $selected -gt 0 ]; then
                local new_selected=$((selected - 1))
                __ARCHIVELIST__.selected = $new_selected
                
                local scroll=$(__ARCHIVELIST__.scroll)
                if [ $new_selected -lt $scroll ]; then
                    __ARCHIVELIST__.scroll = $new_selected
                fi
            fi
            ;;
        DOWN)
            if [ $selected -lt $((count - 1)) ]; then
                local new_selected=$((selected + 1))
                __ARCHIVELIST__.selected = $new_selected
                
                local scroll=$(__ARCHIVELIST__.scroll)
                if [ $new_selected -ge $((scroll + max_visible)) ]; then
                    __ARCHIVELIST__.scroll = $((scroll + 1))
                fi
            fi
            ;;
        PAGEUP)
            local new_selected=$((selected - max_visible))
            [ $new_selected -lt 0 ] && new_selected=0
            __ARCHIVELIST__.selected = $new_selected
            
            local scroll=$(__ARCHIVELIST__.scroll)
            if [ $new_selected -lt $scroll ]; then
                __ARCHIVELIST__.scroll = $new_selected
            fi
            ;;
        PAGEDOWN)
            local new_selected=$((selected + max_visible))
            [ $new_selected -ge $count ] && new_selected=$((count - 1))
            __ARCHIVELIST__.selected = $new_selected
            
            local scroll=$(__ARCHIVELIST__.scroll)
            if [ $new_selected -ge $((scroll + max_visible)) ]; then
                __ARCHIVELIST__.scroll = $((new_selected - max_visible + 1))
            fi
            ;;
        HOME)
            __ARCHIVELIST__.selected = 0
            __ARCHIVELIST__.scroll = 0
            ;;
        END)
            __ARCHIVELIST__.selected = $((count - 1))
            local scroll=$((count - max_visible))
            [ $scroll -lt 0 ] && scroll=0
            __ARCHIVELIST__.scroll = $scroll
            ;;
    esac
}

# Extract files to destination directory
# $1 = destination directory
# $2... = internal paths to extract (empty = extract all)
__ARCHIVELIST__.extract_files(){
    local dest="$1"
    shift
    local files=("$@")

    local archive_path=$(__ARCHIVELIST__.archive_path)
    local archive_type=$(__ARCHIVELIST__.archive_type)

    mkdir -p "$dest" 2>/dev/null || return 1

    if [ ${#files[@]} -eq 0 ]; then
        # Extract everything
        case "$archive_type" in
            tar|tar.gz|tar.bz2|tar.xz)
                tar -xf "$archive_path" -C "$dest" 2>/dev/null ;;
            zip)
                unzip -q "$archive_path" -d "$dest" 2>/dev/null ;;
            rar)
                unrar x -y "$archive_path" "$dest/" 2>/dev/null ;;
            7z)
                local cmd=""
                command -v 7z &>/dev/null && cmd="7z"
                command -v 7za &>/dev/null && [ -z "$cmd" ] && cmd="7za"
                command -v 7zr &>/dev/null && [ -z "$cmd" ] && cmd="7zr"
                [ -n "$cmd" ] && $cmd x "$archive_path" -o"$dest" -y 2>/dev/null ;;
            deb)
                dpkg-deb -x "$archive_path" "$dest" 2>/dev/null ;;
            rpm)
                if command -v rpm2cpio &>/dev/null && command -v cpio &>/dev/null; then
                    ( cd "$dest" && rpm2cpio "$archive_path" | cpio -idm --quiet 2>/dev/null )
                fi ;;
        esac
    else
        # Extract specific files
        case "$archive_type" in
            tar|tar.gz|tar.bz2|tar.xz)
                local tmp=$(mktemp -d)
                tar -xf "$archive_path" -C "$tmp" "${files[@]}" 2>/dev/null
                for f in "${files[@]}"; do
                    local src="$tmp/${f#/}"
                    [ -e "$src" ] && cp -r "$src" "$dest/" 2>/dev/null
                done
                rm -rf "$tmp" ;;
            zip)
                local tmp=$(mktemp -d)
                unzip -q "$archive_path" "${files[@]}" -d "$tmp" 2>/dev/null
                for f in "${files[@]}"; do
                    local src="$tmp/${f#/}"
                    [ -e "$src" ] && cp -r "$src" "$dest/" 2>/dev/null
                done
                rm -rf "$tmp" ;;
            rar)
                local tmp=$(mktemp -d)
                for f in "${files[@]}"; do
                    unrar x -y "$archive_path" "$f" "$tmp/" 2>/dev/null
                    local src="$tmp/${f#/}"
                    [ -e "$src" ] && cp -r "$src" "$dest/" 2>/dev/null
                done
                rm -rf "$tmp" ;;
            7z)
                local cmd=""
                command -v 7z &>/dev/null && cmd="7z"
                command -v 7za &>/dev/null && [ -z "$cmd" ] && cmd="7za"
                command -v 7zr &>/dev/null && [ -z "$cmd" ] && cmd="7zr"
                if [ -n "$cmd" ]; then
                    local tmp=$(mktemp -d)
                    for f in "${files[@]}"; do
                        $cmd x "$archive_path" -o"$tmp" -y "$f" 2>/dev/null
                        local src="$tmp/${f#/}"
                        [ -e "$src" ] && cp -r "$src" "$dest/" 2>/dev/null
                    done
                    rm -rf "$tmp"
                fi ;;
            deb)
                local tmp=$(mktemp -d)
                dpkg-deb -x "$archive_path" "$tmp" 2>/dev/null
                for f in "${files[@]}"; do
                    local src="$tmp/${f#/}"
                    [ -e "$src" ] && cp -r "$src" "$dest/" 2>/dev/null
                done
                rm -rf "$tmp" ;;
            rpm)
                if command -v rpm2cpio &>/dev/null && command -v cpio &>/dev/null; then
                    local tmp=$(mktemp -d)
                    ( cd "$tmp" && rpm2cpio "$archive_path" | cpio -idm --quiet 2>/dev/null )
                    for f in "${files[@]}"; do
                        local src="$tmp/${f#/}"
                        [ -e "$src" ] && cp -r "$src" "$dest/" 2>/dev/null
                    done
                    rm -rf "$tmp"
                fi ;;
        esac
    fi
}

# Cleanup - clear all arrays to free memory
__ARCHIVELIST__.cleanup(){
    __ARCHIVELIST___all_entries=()
    __ARCHIVELIST___files=()
    __ARCHIVELIST___types=()
    __ARCHIVELIST___sizes=()
    __ARCHIVELIST___times=()
    __ARCHIVELIST___full_paths=()
    __ARCHIVELIST__.selected = 0
    __ARCHIVELIST__.scroll = 0
}

# Check if special entry
__ARCHIVELIST__.is_special(){
    local filename="$1"
    [[ "$filename" == ".." || "$filename" == "<empty>" ]]
}

# Enter directory
__ARCHIVELIST__.enter(){
    local selected=$(__ARCHIVELIST__.selected)
    local filename="${__ARCHIVELIST___files[$selected]}"
    local filetype="${__ARCHIVELIST___types[$selected]}"
    
    if [ "$filename" = ".." ]; then
        # Go up one level
        local internal=$(__ARCHIVELIST__.internal_path)
        
        local leaving_dir="${internal##*/}"
        local parent="${internal%/*}"
        
        if [ "$parent" = "$internal" ]; then
            parent=""
        fi
        
        __ARCHIVELIST__.internal_path = "$parent"
        __ARCHIVELIST__.load
        
        # Find and select the directory we just left (with scroll adjustment)
        if [ -n "$leaving_dir" ]; then
            # Get max_visible from panel height (estimate 20 if unknown)
            __ARCHIVELIST__.find_and_select "$leaving_dir" 20
        fi
    elif [ "$filetype" = "d" ]; then
        # Enter subdirectory
        local internal=$(__ARCHIVELIST__.internal_path)
        
        if [ -z "$internal" ]; then
            __ARCHIVELIST__.internal_path = "$filename"
        else
            __ARCHIVELIST__.internal_path = "$internal/$filename"
        fi
        
        __ARCHIVELIST__.load
    fi
}

# Get selected item info
__ARCHIVELIST__.get_selected_item(){
    local selected=$(__ARCHIVELIST__.selected)
    local filename="${__ARCHIVELIST___files[$selected]}"
    local filetype="${__ARCHIVELIST___types[$selected]}"
    local path="${__ARCHIVELIST___full_paths[$selected]}"
    
    echo "$filename|$filetype|$path"
}

# Stub methods for filelist API compatibility
__ARCHIVELIST__.count_selected(){ echo 0; }
__ARCHIVELIST__.toggle_selection(){ :; }
__ARCHIVELIST__.selection_info(){ echo "0|0"; }
__ARCHIVELIST__.find_and_select(){
    local target_name="$1"
    local max_visible="${2:-20}"
    
    local count=${#__ARCHIVELIST___files[@]}
    
    # Search for the item
    for ((i=0; i<count; i++)); do
        if [ "${__ARCHIVELIST___files[$i]}" = "$target_name" ]; then
            # Found it - select and adjust scroll
            __ARCHIVELIST__.selected = $i
            
            # Adjust scroll to make it visible
            local scroll=$(__ARCHIVELIST__.scroll)
            if [ $i -lt $scroll ]; then
                scroll=$i
            elif [ $i -ge $((scroll + max_visible)) ]; then
                scroll=$((i - max_visible + 1))
            fi
            
            # Clamp scroll to prevent empty rows at bottom
            local max_scroll=$((count - max_visible))
            if [ $max_scroll -lt 0 ]; then
                max_scroll=0
            fi
            if [ $scroll -gt $max_scroll ]; then
                scroll=$max_scroll
            fi
            
            __ARCHIVELIST__.scroll = $scroll
            return 0
        fi
    done
    
    # Not found - leave selection as is
    return 1
}
__ARCHIVELIST__.sort_order(){ echo "name_asc"; }
__ARCHIVELIST__.marked_size(){ echo 0; }
__ARCHIVELIST__.marked_count(){ echo 0; }
__ARCHIVELIST__.type(){ echo "archive"; }
__ARCHIVELIST__.get_selected(){ __ARCHIVELIST__.get_selected_item; }

