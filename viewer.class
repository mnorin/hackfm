#!/bin/bash
# viewer.class - File viewer using ba.sh

# Load dependencies
. "$HACKFM_DIR/appframe.h"

__VIEWER___properties=()

__VIEWER__.property(){
    # Property indices
    local filepath=0
    local scroll=1
    local appframe_created=2
    
    if [ "$2" = "=" ]; then
        __VIEWER___properties[$1]="$3"
    else
        echo "${__VIEWER___properties[$1]}"
    fi
}

# Property accessors
__VIEWER__.filepath(){
    if [ "$1" = "=" ]; then
        __VIEWER__.property filepath = "$2"
    else
        __VIEWER__.property filepath
    fi
}

__VIEWER__.scroll(){
    if [ "$1" = "=" ]; then
        __VIEWER__.property scroll = "$2"
    else
        __VIEWER__.property scroll
    fi
}

__VIEWER__.appframe_created(){
    if [ "$1" = "=" ]; then
        __VIEWER__.property appframe_created = "$2"
    else
        local val=$(__VIEWER__.property appframe_created)
        echo "${val:-0}"
    fi
}

# File lines array
declare -ag __VIEWER___lines=()

# Load file - checks view.conf for a text-conversion handler first,
# falls back to reading the file directly if no handler or command not found
__VIEWER__.load(){
    local filepath="$1"
    local ext="${filepath##*.}"
    ext="${ext,,}"  # lowercase

    __VIEWER__.filepath = "$filepath"
    __VIEWER___lines=()
    __VIEWER__.scroll = 0

    # Check view.conf for a handler for this extension (read fresh each time)
    # Full line after the extension is the command template; %f is replaced with
    # the filepath, or filepath is appended if %f is absent
    local handler=""
    local view_conf="$HACKFM_DIR/conf/view.conf"
    if [ -f "$view_conf" ]; then
        while IFS= read -r conf_line || [ -n "$conf_line" ]; do
            [[ -z "$conf_line" || "$conf_line" == \#* ]] && continue
            local conf_ext="${conf_line%% *}"
            local conf_cmd="${conf_line#*[[:space:]]}"
            # Trim leading whitespace (config uses spaces for alignment)
            while [[ "$conf_cmd" == [[:space:]]* ]]; do conf_cmd="${conf_cmd#?}"; done
            if [ "${conf_ext,,}" = "$ext" ]; then
                handler="$conf_cmd"
                break
            fi
        done < "$view_conf"
    fi

    # Build and run the command - substitute %f or append filepath
    local use_handler=0
    if [ -n "$handler" ] && command -v "${handler%% *}" &>/dev/null; then
        local cmd
        if [[ "$handler" == *%f* ]]; then
            cmd="${handler//%f/\"$filepath\"}"
        else
            cmd="$handler \"$filepath\""
        fi

        while IFS= read -r line; do
            line="${line%$'\r'}"
            # Replace form feed (page break) with empty line
            line="${line//$'\f'/}"
            # Strip other control chars (keep tab)
            line=$(printf '%s' "$line" | tr '\000-\010\013-\037\177' '.')
            __VIEWER___lines+=("$line")
        done < <(eval "$cmd" 2>/dev/null)

        [ ${#__VIEWER___lines[@]} -gt 0 ] && use_handler=1
    fi

    # Direct file read (fallback or no handler)
    if [ $use_handler -eq 0 ]; then
        __VIEWER___lines=()
        # Detect binary files - check for null bytes in first 8KB
        if LC_ALL=C grep -qP '\x00' <(head -c 8192 "$filepath" 2>/dev/null) 2>/dev/null; then
            local size=$(stat -c '%s' "$filepath" 2>/dev/null || echo "unknown")
            local mime=$(file -b --mime-type "$filepath" 2>/dev/null || echo "unknown")
            __VIEWER___lines+=("[Binary file]")
            __VIEWER___lines+=("")
            __VIEWER___lines+=("  Type: $mime")
            __VIEWER___lines+=("  Size: $size bytes")
            __VIEWER___lines+=("")
            __VIEWER___lines+=("  No viewer configured for this file type.")
            __VIEWER___lines+=("  Add an entry to \$HACKFM_DIR/conf/view.conf to handle it.")
        else
            while IFS= read -r line; do
                line="${line%$'\r'}"
                line=$(printf '%s' "$line" | tr '\000-\010\013-\037\177' '.')
                __VIEWER___lines+=("$line")
            done < "$filepath"
        fi
    fi
}


__VIEWER__.display_content(){
        local row=2
        for ((i=scroll; i<scroll+max_rows && i<total_lines; i++)); do
            tui.cursor.move $row 1
            tui.color.bg_blue
            tui.color.bright_white

            # Truncate long lines - use cut for byte-safe truncation
            local display_line="${__VIEWER___lines[$i]}"
            local display_len=$(printf '%s' "$display_line" | wc -m)
            if [ "$display_len" -gt "$cols" ]; then
                display_line=$(printf '%s' "$display_line" | cut -c1-$((cols - 3)))
                display_line+="..."
            fi

            printf '%s' "$display_line"
            # Clear to end of line - handles multi-byte chars correctly
            printf '\033[K'
            tui.style.reset
            ((row++)) || true
        done

        # Fill any remaining rows below content with solid blue
        while [ $row -le $((max_rows + 1)) ]; do
            tui.cursor.move $row 1
            tui.color.bg_blue
            printf '\033[K'
            tui.style.reset
            ((row++)) || true
        done
}

# Show viewer (blocking - runs until user exits)
__VIEWER__.show(){
    local filepath=$(__VIEWER__.filepath)
    local filename=$(basename "$filepath")
    
    # Check if file is loaded
    if [ -z "$filepath" ]; then
        return 1
    fi
    
    # Create appframe if not already created
    local appframe_created=$(__VIEWER__.appframe_created)
    if [ $appframe_created -eq 0 ]; then
        appframe __VIEWER___appframe
        __VIEWER__.appframe_created = 1
    fi
    
    # Configure appframe
    __VIEWER___appframe.title = " File: $filename"
    __VIEWER___appframe.show_cursor = 0
    
    # Setup
    __VIEWER___appframe.setup
    
    # Get dimensions
    local rows=$(__VIEWER___appframe.rows)
    local cols=$(__VIEWER___appframe.cols)
    local content_height=$(__VIEWER___appframe.main_height)
    local total_lines=${#__VIEWER___lines[@]}
    
    __VIEWER___appframe.draw_frame_blue "Help" "" "Quit" "" "" "" "" "" "" "Quit"

    # Empty file check
    if [ ${#__VIEWER___lines[@]} -eq 0 ]; then
        tui.cursor.move 3 1
        tui.color.bg_blue
        tui.color.white
        echo "<empty file>"
        tui.color.reset
    fi
    
    # Viewer loop
    local scroll=$(__VIEWER__.scroll)
    local max_rows=$content_height
    
    __VIEWER__.display_content

    while true; do
        # Update title with line info
        local current_line=$((scroll + 1))
        __VIEWER___appframe.title = " File: $filename | Line $current_line/$total_lines"
        __VIEWER___appframe.draw_title
        
        # Input
        local key=$(tui.input.key)
        local old_scroll=$scroll
        
        case "$key" in
            UP)
                [ $scroll -gt 0 ] && ((scroll--))
                ;;
            DOWN)
                [ $scroll -lt $((total_lines - max_rows)) ] && ((scroll++)) || true
                ;;
            PAGEUP)
                scroll=$((scroll - max_rows))
                [ $scroll -lt 0 ] && scroll=0
                ;;
            PAGEDOWN)
                scroll=$((scroll + max_rows))
                local max_scroll=$((total_lines - max_rows))
                [ $max_scroll -lt 0 ] && max_scroll=0
                [ $scroll -gt $max_scroll ] && scroll=$max_scroll
                ;;
            HOME)
                scroll=0
                ;;
            END)
                scroll=$((total_lines - max_rows))
                [ $scroll -lt 0 ] && scroll=0
                ;;
            q|Q|F3|F10)
                break
                ;;
        esac
        
        # Optimize redraw for single-line scroll
        local scroll_delta=$((scroll - old_scroll))
        
        if [ $scroll_delta -eq 1 ]; then
            # Scrolled DOWN by 1 - use scroll region
            tui.cursor.hide
            
            # Set scroll region (content area: rows 2 to rows-1)
            local region_bottom=$((rows - 1))
            tui.region.set 2 $region_bottom
            
            # Move to bottom and scroll up (content moves up)
            tui.cursor.move $region_bottom 1
            tui.region.scroll_up
            
            # Draw new bottom line
            local new_line_idx=$((scroll + max_rows - 1))
            if [ $new_line_idx -lt $total_lines ]; then
                tui.cursor.move $region_bottom 1
                tui.color.bg_blue
                tui.color.bright_white
                local display_line="${__VIEWER___lines[$new_line_idx]}"
                local display_len=$(printf '%s' "$display_line" | wc -m)
                if [ "$display_len" -gt "$cols" ]; then
                    display_line=$(printf '%s' "$display_line" | cut -c1-$((cols - 3)))
                    display_line+="..."
                fi
                printf '%s' "$display_line"
                printf '\033[K'
                tui.style.reset
            fi
            
            # Reset scroll region
            tui.region.reset
            
        elif [ $scroll_delta -eq -1 ]; then
            # Scrolled UP by 1 - use scroll region
            tui.cursor.hide
            
            # Set scroll region (content area: rows 2 to rows-1)
            local region_bottom=$((rows - 1))
            tui.region.set 2 $region_bottom
            
            # Move to top and scroll down (content moves down)
            tui.cursor.move 2 1
            tui.region.scroll_down
            
            # Draw new top line
            tui.cursor.move 2 1
            tui.color.bg_blue
            tui.color.bright_white
            local display_line="${__VIEWER___lines[$scroll]}"
            local display_len=$(printf '%s' "$display_line" | wc -m)
            if [ "$display_len" -gt "$cols" ]; then
                display_line=$(printf '%s' "$display_line" | cut -c1-$((cols - 3)))
                display_line+="..."
            fi
            printf '%s' "$display_line"
            printf '\033[K'
            tui.style.reset
            
            # Reset scroll region
            tui.region.reset
            
        elif [ $scroll_delta -ne 0 ]; then
            __VIEWER__.display_content
        fi
    done
    
    # Save scroll position
    __VIEWER__.scroll = $scroll
    
    # Cleanup
    # __VIEWER___appframe.cleanup
}

# Open file (convenience method that loads and shows)
__VIEWER__.open(){
    local filepath="$1"
    __VIEWER__.load "$filepath"
    __VIEWER__.show
}
